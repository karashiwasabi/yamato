----- C:\Dev\YAMATO\dat\dat.go -----
package dat  import ( 	"bufio" 	"io" 	"log" 	"strings"  	"golang.org/x/text/encoding/japanese" 	"golang.org/x/text/transform"  	"YAMATO/ma0" // モジュール名は "YAMATO" 固定 )  // DATRecord は、DAT ファイルから抽出した各フィールドの値を保持する構造体です。 type DATRecord struct { 	DatOroshiCode         string // S 行で取得した卸コード（raw[3:14]） 	DatDate               string // D 行から raw[4:12]（YYYYMMDD形式） 	DatDeliveryFlag       string // D 行から raw[3:4] 	DatReceiptNumber      string // D 行から raw[12:22] 	DatLineNumber         string // D 行から raw[22:24] 	DatJanCode            string // D 行から raw[25:38] ※仕様書準拠の13バイト 	DatProductName        string // D 行から raw[38:78] → 必要部分のみ Shift‑JIS→UTF‑8 変換適用 	DatQuantity           string // D 行から raw[78:83] 	DatUnitPrice          string // D 行から raw[83:92] 	DatSubtotal           string // D 行から raw[92:101] 	DatPackagingDrugPrice string // D 行から raw[101:109] 	DatExpiryDate         string // D 行から raw[109:115] 	DatLotNumber          string // D 行から raw[115:121] }  // ProcessDATRecord は、作成した 13 項目のスライスを用いて、 // MA0 の重複チェック／新規登録処理（CheckOrCreateMA0）を呼び出します。 // ここでは、スライスの index 4 が JAN コードであると仮定しています。 func ProcessDATRecord(data []string) error { 	if len(data) < 5 { 		return nil // 想定外のケースでは処理しない 	} 	jan := data[4] // index 4 にJANコードが入っています 	_, created, err := ma0.CheckOrCreateMA0(jan) 	if err != nil { 		return err 	} 	if created { 		log.Printf("[DAT] MA0 新規レコード作成: JAN=%q, 全データ=%#v", jan, data) 	} else { 		log.Printf("[DAT] 既存の MA0 レコード利用: JAN=%q, 全データ=%#v", jan, data) 	} 	return nil }  // ParseDATFile は、io.Reader から DAT ファイルの内容を読み込み、 // S 行で取得された卸コードを D 行の各レコードに適用しながら、 // 各 D 行の値を DATRecord に変換します。 // また、仕様に沿った固定長フィールドの抽出を行いながら、 // その D 行の各データから、13 項目のスライス（recordData）を生成し、 // MA0 へのデータ送信／重複チェック処理（ProcessDATRecord）を呼び出します。 // なお、総件数、MA0 の新規登録件数、重複件数は返却値として集計可能ですが、 // この例では後続処理用に変数 totalCount などを更新した上で、最終的に返しています。 func ParseDATFile(r io.Reader) (records []DATRecord, totalCount, ma0CreatedCount, duplicateCount int, err error) { 	scanner := bufio.NewScanner(r) 	var currentOroshiCode string = "" 	for scanner.Scan() { 		line := scanner.Text() 		if len(line) < 3 { 			continue 		} 		// S 行の場合：識別子 "S20" で卸コードを取得 		if strings.HasPrefix(line, "S20") { 			// 仕様書では raw[3:14] が卸コードとされています 			currentOroshiCode = strings.TrimSpace(line[3:14]) 			continue 		} 		// D 行のみを対象とする（識別子 "D20"） 		if !strings.HasPrefix(line, "D20") { 			continue 		} 		totalCount++  		// 固定長フィールド抽出のヘルパー関数 		getField := func(s string, start, end int) string { 			if len(s) >= end { 				return s[start:end] 			} 			if len(s) > start { 				return s[start:] 			} 			return "" 		}  		// 各フィールドを仕様書に基づく位置から抽出 		datDate := getField(line, 4, 12) 		datDeliveryFlag := getField(line, 3, 4) 		datReceiptNumber := getField(line, 12, 22) 		datLineNumber := getField(line, 22, 24) 		datJanCode := getField(line, 25, 38) 		rawProductName := getField(line, 38, 78) 		// 商品名は Shift‑JIS から UTF‑8 へ変換する 		datProductName, _, errConv := transform.String(japanese.ShiftJIS.NewDecoder(), rawProductName) 		if errConv != nil { 			log.Printf("[DAT] 商品名変換エラー: %v", errConv) 			datProductName = rawProductName 		} 		datQuantity := getField(line, 78, 83) 		datUnitPrice := getField(line, 83, 92) 		datSubtotal := getField(line, 92, 101) 		datPackagingDrugPrice := getField(line, 101, 109) 		datExpiryDate := getField(line, 109, 115) 		datLotNumber := getField(line, 115, 121)  		// --- 元々の解析部分（既存機能） --- 		record := DATRecord{ 			DatOroshiCode:         currentOroshiCode, 			DatDate:               datDate, 			DatDeliveryFlag:       datDeliveryFlag, 			DatReceiptNumber:      datReceiptNumber, 			DatLineNumber:         datLineNumber, 			DatJanCode:            datJanCode, 			DatProductName:        datProductName, 			DatQuantity:           datQuantity, 			DatUnitPrice:          datUnitPrice, 			DatSubtotal:           datSubtotal, 			DatPackagingDrugPrice: datPackagingDrugPrice, 			DatExpiryDate:         datExpiryDate, 			DatLotNumber:          datLotNumber, 		} 		records = append(records, record) 		// --- ここまでが元々の解析部分 ---  		// -- 新たに追加する処理 -- 		// 仕様に沿って、13 項目のスライス recordData を生成する。 		// 順番は以下: 		//  0: DatOroshiCode, 1: DatDate, 2: DatDeliveryFlag, 3: DatReceiptNumber, 		//  4: DatJanCode, 5: DatLineNumber, 6: DatProductName, 7: DatQuantity, 		//  8: DatUnitPrice, 9: DatSubtotal, 10: DatPackagingDrugPrice, 		//  11: DatExpiryDate, 12: DatLotNumber 		recordData := []string{ 			currentOroshiCode, 			datDate, 			datDeliveryFlag, 			datReceiptNumber, 			datJanCode, // KEYとなるJANコード 			datLineNumber, 			datProductName, 			datQuantity, 			datUnitPrice, 			datSubtotal, 			datPackagingDrugPrice, 			datExpiryDate, 			datLotNumber, 		}  		// 既存のコードを変更せずに、新たな MA0 へのデータ連携処理を重ねます。 		if errProcessing := ProcessDATRecord(recordData); errProcessing != nil { 			log.Printf("[DAT] MA0 処理エラー: %v", errProcessing) 		} 		// ※ ここで個々のレコードに対して MA0 への送信処理が呼ばれます。 	}  	if errScan := scanner.Err(); errScan != nil { 		err = errScan 	} 	return }

----- C:\Dev\YAMATO\jancode\jancode.go -----
package jancode  import ( 	"encoding/csv" 	"io" 	"log" )  // JAFields は、JANCODE CSVから取り出す JA領域の各フィールドを保持する構造体です。 // 例として、JA000、JA001、JA029 を定義していますが、必要に応じて中間のフィールドも追加してください。 type JAFields struct { 	JA000 string 	JA001 string 	JA002 string 	JA003 string 	JA004 string 	JA005 string 	JA006 string 	JA007 string 	JA008 string 	JA009 string 	JA010 string 	JA011 string 	JA012 string 	JA013 string 	JA014 string 	JA015 string 	JA016 string 	JA017 string 	JA018 string 	JA019 string 	JA020 string 	JA021 string 	JA022 string 	JA023 string 	JA024 string 	JA025 string 	JA026 string 	JA027 string 	JA028 string 	JA029 string }  // JANCODERecord は、JANCODE CSVの1行分のデータを表します。 // キーは、フィールド1の値（JANコード）として使用し、JA領域の情報を保持します。 type JANCODERecord struct { 	JANCode string   // CSVのインデックス1 (JANコード) 	JA      JAFields // JA領域の情報 }  // ParseJANCODE は、入力の io.Reader から CSV データを読み込み、 // ヘッダー行をスキップした上で各行を JANCODERecord のスライスに変換して返します。 // CSVは各行が少なくとも30フィールド（インデックス0～29）を持つことを前提としています。 func ParseJANCODE(r io.Reader) ([]JANCODERecord, error) { 	reader := csv.NewReader(r) 	rows, err := reader.ReadAll() 	if err != nil { 		return nil, err 	}  	var records []JANCODERecord 	for i, row := range rows { 		// 1行目はヘッダーのためスキップ 		if i == 0 { 			continue 		}  		if len(row) < 30 { 			log.Printf("Row %d: insufficient fields (%d)", i+1, len(row)) 			continue 		}  		ja := JAFields{ 			JA000: row[0], 			JA001: row[1], 			JA002: row[2], 			JA003: row[3], 			JA004: row[4], 			JA005: row[5], 			JA006: row[6], 			JA007: row[7], 			JA008: row[8], 			JA009: row[9], 			JA010: row[10], 			JA011: row[11], 			JA012: row[12], 			JA013: row[13], 			JA014: row[14], 			JA015: row[15], 			JA016: row[16], 			JA017: row[17], 			JA018: row[18], 			JA019: row[19], 			JA020: row[20], 			JA021: row[21], 			JA022: row[22], 			JA023: row[23], 			JA024: row[24], 			JA025: row[25], 			JA026: row[26], 			JA027: row[27], 			JA028: row[28], 			JA029: row[29], 		}  		record := JANCODERecord{ 			JANCode: row[1], // キーとしてフィールド1の値を使用 			JA:      ja, 		}  		records = append(records, record) 	} 	return records, nil }

----- C:\Dev\YAMATO\jchms\jchms.go -----
package jchms  import ( 	"encoding/csv" 	"io" 	"log" )  // JCFields は、JCHMAS CSVから取り出す JC 領域の各フィールドを保持する構造体です。 // ここでは例として JC000, JC001, JC124 を定義していますが、必要に応じて他のフィールドも追加してください。 type JCFields struct { 	JC000 string 	JC001 string 	JC002 string 	JC003 string 	JC004 string 	JC005 string 	JC006 string 	JC007 string 	JC008 string 	JC009 string 	JC010 string 	JC011 string 	JC012 string 	JC013 string 	JC014 string 	JC015 string 	JC016 string 	JC017 string 	JC018 string 	JC019 string 	JC020 string 	JC021 string 	JC022 string 	JC023 string 	JC024 string 	JC025 string 	JC026 string 	JC027 string 	JC028 string 	JC029 string 	JC030 string 	JC031 string 	JC032 string 	JC033 string 	JC034 string 	JC035 string 	JC036 string 	JC037 string 	JC038 string 	JC039 string 	JC040 string 	JC041 string 	JC042 string 	JC043 string 	JC044 string 	JC045 string 	JC046 string 	JC047 string 	JC048 string 	JC049 string 	JC050 string 	JC051 string 	JC052 string 	JC053 string 	JC054 string 	JC055 string 	JC056 string 	JC057 string 	JC058 string 	JC059 string 	JC060 string 	JC061 string 	JC062 string 	JC063 string 	JC064 string 	JC065 string 	JC066 string 	JC067 string 	JC068 string 	JC069 string 	JC070 string 	JC071 string 	JC072 string 	JC073 string 	JC074 string 	JC075 string 	JC076 string 	JC077 string 	JC078 string 	JC079 string 	JC080 string 	JC081 string 	JC082 string 	JC083 string 	JC084 string 	JC085 string 	JC086 string 	JC087 string 	JC088 string 	JC089 string 	JC090 string 	JC091 string 	JC092 string 	JC093 string 	JC094 string 	JC095 string 	JC096 string 	JC097 string 	JC098 string 	JC099 string 	JC100 string 	JC101 string 	JC102 string 	JC103 string 	JC104 string 	JC105 string 	JC106 string 	JC107 string 	JC108 string 	JC109 string 	JC110 string 	JC111 string 	JC112 string 	JC113 string 	JC114 string 	JC115 string 	JC116 string 	JC117 string 	JC118 string 	JC119 string 	JC120 string 	JC121 string 	JC122 string 	JC123 string 	JC124 string }  // JCHMASRecord は、JCHMAS（旧JCHMS）CSVの1行分を表します。 // キーはフィールド0（JANコード）とし、JC領域の情報を構造体として保持します。 type JCHMASRecord struct { 	JANCode string   // CSV のインデックス0 (JANコード) 	JC      JCFields // JC 領域の情報 }  // ParseJCHMAS は、入力の io.Reader から CSV データを読み込み、 // 各行を JCHMASRecord のスライスに変換して返します。 // CSV はヘッダーなしで、各行は少なくとも 125 フィールド（0〜124）を持つことが前提です。 func ParseJCHMAS(r io.Reader) ([]JCHMASRecord, error) { 	reader := csv.NewReader(r) 	rows, err := reader.ReadAll() 	if err != nil { 		return nil, err 	}  	var records []JCHMASRecord 	for i, row := range rows { 		// 行のフィールド数が125未満の場合は、警告を出してその行をスキップ 		if len(row) < 125 { 			log.Printf("Row %d: insufficient fields (%d)", i+1, len(row)) 			continue 		}  		// JC領域のデータを構造体に格納 		jc := JCFields{ 			JC000: row[0], 			JC001: row[1], 			JC002: row[2], 			JC003: row[3], 			JC004: row[4], 			JC005: row[5], 			JC006: row[6], 			JC007: row[7], 			JC008: row[8], 			JC009: row[9], 			JC010: row[10], 			JC011: row[11], 			JC012: row[12], 			JC013: row[13], 			JC014: row[14], 			JC015: row[15], 			JC016: row[16], 			JC017: row[17], 			JC018: row[18], 			JC019: row[19], 			JC020: row[20], 			JC021: row[21], 			JC022: row[22], 			JC023: row[23], 			JC024: row[24], 			JC025: row[25], 			JC026: row[26], 			JC027: row[27], 			JC028: row[28], 			JC029: row[29], 			JC030: row[30], 			JC031: row[31], 			JC032: row[32], 			JC033: row[33], 			JC034: row[34], 			JC035: row[35], 			JC036: row[36], 			JC037: row[37], 			JC038: row[38], 			JC039: row[39], 			JC040: row[40], 			JC041: row[41], 			JC042: row[42], 			JC043: row[43], 			JC044: row[44], 			JC045: row[45], 			JC046: row[46], 			JC047: row[47], 			JC048: row[48], 			JC049: row[49], 			JC050: row[50], 			JC051: row[51], 			JC052: row[52], 			JC053: row[53], 			JC054: row[54], 			JC055: row[55], 			JC056: row[56], 			JC057: row[57], 			JC058: row[58], 			JC059: row[59], 			JC060: row[60], 			JC061: row[61], 			JC062: row[62], 			JC063: row[63], 			JC064: row[64], 			JC065: row[65], 			JC066: row[66], 			JC067: row[67], 			JC068: row[68], 			JC069: row[69], 			JC070: row[70], 			JC071: row[71], 			JC072: row[72], 			JC073: row[73], 			JC074: row[74], 			JC075: row[75], 			JC076: row[76], 			JC077: row[77], 			JC078: row[78], 			JC079: row[79], 			JC080: row[80], 			JC081: row[81], 			JC082: row[82], 			JC083: row[83], 			JC084: row[84], 			JC085: row[85], 			JC086: row[86], 			JC087: row[87], 			JC088: row[88], 			JC089: row[89], 			JC090: row[90], 			JC091: row[91], 			JC092: row[92], 			JC093: row[93], 			JC094: row[94], 			JC095: row[95], 			JC096: row[96], 			JC097: row[97], 			JC098: row[98], 			JC099: row[99], 			JC100: row[100], 			JC101: row[101], 			JC102: row[102], 			JC103: row[103], 			JC104: row[104], 			JC105: row[105], 			JC106: row[106], 			JC107: row[107], 			JC108: row[108], 			JC109: row[109], 			JC110: row[110], 			JC111: row[111], 			JC112: row[112], 			JC113: row[113], 			JC114: row[114], 			JC115: row[115], 			JC116: row[116], 			JC117: row[117], 			JC118: row[118], 			JC119: row[119], 			JC120: row[120], 			JC121: row[121], 			JC122: row[122], 			JC123: row[123], 			JC124: row[124], 		}  		// レコードを生成（キーは row[0] の JANコード） 		record := JCHMASRecord{ 			JANCode: row[0], 			JC:      jc, 		} 		records = append(records, record) 	} 	return records, nil }

----- C:\Dev\YAMATO\js\dat.js -----
document.addEventListener('DOMContentLoaded', () => {   const uploadBtn = document.getElementById('uploadBtn');   const fileInput = document.getElementById('fileInput');   const indicator = document.getElementById('indicator');   const output = document.getElementById('output');    if (!uploadBtn || !fileInput || !indicator || !output) {     console.error("必要な DOM 要素が見つかりません。HTML を確認してください。");     return;   }    // アップロードボタンをクリックでファイル選択ダイアログを表示   uploadBtn.addEventListener('click', () => {     fileInput.click();   });    fileInput.addEventListener('change', async () => {     const files = fileInput.files;     if (!files || files.length === 0) {       console.warn("ファイルが選択されていません。");       return;     }      // Indicator に選択されたファイル数を表示     indicator.textContent = `${files.length} 個のファイルが選択されました。`;      let results = [];     // 各ファイルを1個ずつアップロード     for (let i = 0; i < files.length; i++) {       const formData = new FormData();       formData.append('file', files[i]);        try {         const res = await fetch('/upload', {           method: 'POST',           body: formData         });         if (!res.ok) throw new Error(`HTTPエラー: ${res.status}`);         // レスポンスはプレーンテキストとして受け取る         const text = await res.text();         results.push(`[${files[i].name}]:\n${text}`);       } catch (err) {         results.push(`[${files[i].name}]: アップロード失敗 (${err.message})`);       }     }     output.textContent = results.join("\n\n");     indicator.textContent += " アップロード処理が完了しました。";     fileInput.value = '';   }); });

----- C:\Dev\YAMATO\ma0\mao.go -----
package ma0  import ( 	"encoding/json" 	"net/http" 	"sync" )  // MA0Record は MA0 の各レコード情報を保持する構造体です。 type MA0Record struct { 	JANCode          string `json:"janCode"` 	PackagingUnit    string `json:"packagingUnit"` 	ConversionFactor string `json:"conversionFactor"` }  var ( 	// ma0Data は in‑memory のマスター情報を保持します。 	ma0Data = make(map[string]MA0Record) 	// mutex により同時アクセスの排他制御を行います。 	mutex sync.Mutex )  // CheckOrCreateMA0 は、指定された JAN コードについて、 // 既に登録済みかをチェックし、存在すればそのレコードと false を返し、 // 存在しなければダミー値（PackagingUnit: "錠", ConversionFactor: "100"）を用いて // 新規に登録し、登録したレコードと true を返します。エラーは基本的に発生しません。 func CheckOrCreateMA0(jan string) (MA0Record, bool, error) { 	mutex.Lock() 	defer mutex.Unlock()  	if rec, exists := ma0Data[jan]; exists { 		return rec, false, nil 	}  	newRec := MA0Record{ 		JANCode:          jan, 		PackagingUnit:    "錠",   // 仮の値。実際はマスターCSVから取得するなどの処理を追加可能 		ConversionFactor: "100", // 仮の値 	} 	ma0Data[jan] = newRec 	return newRec, true, nil }  // ViewMA0Handler は、現在の MA0 の中身（登録された MA0Record の一覧）を JSON 形式で返却します。 func ViewMA0Handler(w http.ResponseWriter, r *http.Request) { 	mutex.Lock() 	defer mutex.Unlock()  	// ma0Data をスライスに変換して返す。 	var records []MA0Record 	for _, rec := range ma0Data { 		records = append(records, rec) 	}  	w.Header().Set("Content-Type", "application/json") 	json.NewEncoder(w).Encode(map[string]interface{}{ 		"MA0Records": records, 	}) }

----- C:\Dev\YAMATO\static\css\styles.css -----
body {   font-family: Arial, sans-serif;   margin: 1em; } header button {   margin-right: .5em;   padding: .4em 1em; } #indicator {   margin: 1em 0;   font-weight: bold; } #outputTable {   width: 100%;   border-collapse: collapse; } #outputTable th, #outputTable td {   border: 1px solid #ccc;   padding: .3em .6em;   font-size: .85em; } #outputTable th {   background: #f0f0f0;   text-align: left; }

----- C:\Dev\YAMATO\static\js\dat.js -----
document.addEventListener('DOMContentLoaded', () => {   // 各DOM要素の取得   const btn       = document.getElementById('datBtn');   const input     = document.getElementById('datInput');   const indicator = document.getElementById('indicator');   const table     = document.getElementById('outputTable');   const thead     = table.querySelector('thead');   const tbody     = table.querySelector('tbody');    // DATファイルアップロードボタンをクリックで隠しファイル入力をトリガー   btn.addEventListener('click', () => {     input.click();   });    // ファイル選択後の処理   input.addEventListener('change', async () => {     if (!input.files.length) return;      // アップロード開始状態を indicator に表示     indicator.textContent = 'DATアップロード中…';      // テーブルヘッダー、ボディの初期化     thead.innerHTML = `       <tr>         <th>卸コード</th>         <th>日付</th>         <th>納品／返品</th>         <th>伝票番号</th>         <th>行番号</th>         <th>JANコード</th>         <th>商品名</th>         <th>数量</th>         <th>単価</th>         <th>小計</th>         <th>包装薬価</th>         <th>有効期限</th>         <th>ロット番号</th>       </tr>`;     tbody.innerHTML = '';      // 選択された全ファイルについてループ処理     for (let file of input.files) {       const formData = new FormData();       formData.append('datFileInput[]', file);        try {         // /uploadDat エンドポイントに対して POST リクエスト送信         const res = await fetch('/uploadDat', { method: 'POST', body: formData });         if (!res.ok) {           throw new Error(`HTTPステータス: ${res.status}`);         }         // サーバーから返却される JSON を取得（"DATRecords" などのキーを持つ）         const result = await res.json();          // 指定ファイルの処理結果を indicator に表示         indicator.textContent = `${file.name}: DAT読み込み: ${result.DATReadCount} 件 | MA0作成: ${result.MA0CreatedCount} 件 | 重複: ${result.DuplicateCount} 件`;          // DATRecords に含まれる各レコードをテーブルへ追加         if (result.DATRecords && result.DATRecords.length > 0) {           result.DATRecords.forEach(record => {             const tr = document.createElement('tr');             tr.innerHTML = `               <td>${record.DatOroshiCode}</td>               <td>${record.DatDate}</td>               <td>${record.DatDeliveryFlag}</td>               <td>${record.DatReceiptNumber}</td>               <td>${record.DatLineNumber}</td>               <td>${record.DatJanCode}</td>               <td>${record.DatProductName}</td>               <td>${record.DatQuantity}</td>               <td>${record.DatUnitPrice}</td>               <td>${record.DatSubtotal}</td>               <td>${record.DatPackagingDrugPrice}</td>               <td>${record.DatExpiryDate}</td>               <td>${record.DatLotNumber}</td>             `;             tbody.appendChild(tr);           });         }       } catch (err) {         // エラー発生時の処理         indicator.textContent = "アップロード中にエラーが発生しました: " + err.message;         console.error(err);       }     }     // 全ファイル処理完了後のメッセージ     indicator.textContent += " 完了";     // 入力値のリセット     input.value = '';   }); });

----- C:\Dev\YAMATO\static\js\ma0.js -----
document.addEventListener('DOMContentLoaded', () => {   const ma0Btn = document.getElementById('ma0Btn');   const ma0Container = document.getElementById('ma0Container');   const indicator = document.getElementById('indicator');    ma0Btn.addEventListener('click', async () => {     indicator.textContent = 'MA0表示中…';     try {       const res = await fetch('/viewMA0');       if (!res.ok) throw new Error(`HTTPステータス: ${res.status}`);        // サーバから返却される JSON データは、"MA0Records" キーに MA0Record の配列が入っているものとする       const data = await res.json();        if (data.MA0Records && data.MA0Records.length > 0) {         ma0Container.innerHTML =           `<h2>MA0レコード（${data.MA0Records.length} 件）</h2>` +           `<ul>` +           data.MA0Records             .map(rec => `<li>${rec.janCode} (包装単位: ${rec.packagingUnit}, 換算係数: ${rec.conversionFactor})</li>`)             .join('') +           `</ul>`;       } else {         ma0Container.innerHTML = `<h2>MA0は空です。</h2>`;       }       indicator.textContent = '';     } catch (err) {       indicator.textContent = "MA0の表示中にエラー: " + err.message;       console.error(err);     }   }); });

----- C:\Dev\YAMATO\static\js\usage.js -----
document.addEventListener('DOMContentLoaded', () => {   const usageBtn   = document.getElementById('usageBtn');   const usageInput = document.getElementById('usageInput');   const indicator  = document.getElementById('indicator');   const table      = document.getElementById('outputTable');   const thead      = table.querySelector('thead');   const tbody      = table.querySelector('tbody');    usageBtn.addEventListener('click', () => usageInput.click());    usageInput.addEventListener('change', async () => {     if (!usageInput.files || usageInput.files.length === 0) return;      indicator.textContent = 'USAGEアップロード中…';     // 新しいヘッダー（項目名）に合わせて設定     thead.innerHTML = `       <tr>         <th>日付</th>         <th>YJコード</th>         <th>JANコード</th>         <th>商品名</th>         <th>数量</th>         <th>単位コード</th>         <th>単位名称</th>       </tr>`;     tbody.innerHTML = '';      for (let file of usageInput.files) {       const formData = new FormData();       formData.append('usageFileInput[]', file);        try {         const res = await fetch('/uploadUsage', { method: 'POST', body: formData });         if (!res.ok) throw new Error(`HTTPエラー: ${res.status}`);         const result = await res.json();         indicator.textContent = `${file.name}: USAGE読み込み: ${result.TotalRecords} 件`;         if (result.USAGERecords && result.USAGERecords.length > 0) {           result.USAGERecords.forEach(record => {             const tr = document.createElement('tr');             tr.innerHTML = `               <td>${record.usageDate}</td>               <td>${record.usageYjCode}</td>               <td>${record.usageJanCode}</td>               <td>${record.usageProductName}</td>               <td>${record.usageAmount}</td>               <td>${record.usageUnit}</td>               <td>${record.usageUnitName}</td>             `;             tbody.appendChild(tr);           });         }       } catch (error) {         indicator.textContent = "アップロード中にエラー: " + error.message;         console.error("USAGEアップロードエラー:", error);       }     }     indicator.textContent += " 完了";     usageInput.value = '';   }); });

----- C:\Dev\YAMATO\static\index.html -----
<!DOCTYPE html> <html lang="ja"> <head>   <meta charset="UTF-8">   <title>YAMATO Upload</title>   <!-- 必要に応じてスタイルシートを調整 -->   <link rel="stylesheet" href="css/styles.css"> </head> <body>   <header>     <!-- DATファイルアップロードボタン -->     <button id="datBtn">DATファイルアップロード</button>     <!-- USAGEファイルアップロードボタン -->     <button id="usageBtn">USAGEファイルアップロード</button>     <!-- MA0確認ボタン -->     <button id="ma0Btn">MA0確認peropero</button>   </header>      <!-- アップロード処理の進捗や結果を表示するエリア -->   <section id="indicator"></section>      <!-- MA0の中身を表示するエリア -->   <section id="ma0Container"></section>      <!-- 解析結果（必要に応じてテーブル表示） -->   <table id="outputTable">     <thead></thead>     <tbody></tbody>   </table>      <!-- 隠しのファイル入力（DAT/USAGE用） -->   <input type="file" id="datInput" accept=".dat" multiple hidden>   <input type="file" id="usageInput" accept=".csv" multiple hidden>      <!-- JavaScriptファイルの読み込み -->   <script src="js/dat.js"></script>   <script src="js/usage.js"></script>   <script src="js/ma0.js"></script> </body> </html>

----- C:\Dev\YAMATO\tani\tani.go -----
package tani  import ( 	"encoding/csv" 	"io" 	"log"  	"golang.org/x/text/encoding/japanese" 	"golang.org/x/text/transform" )  // ParseTANI は、TANI CSV ファイルを Shift‑JIS から UTF‑8 に変換しながら読み込み、 // 各行のフィールド0（単位コード）をキー、フィールド1（単位名称）を値とするマップを返します。 func ParseTANI(r io.Reader) (map[string]string, error) { 	// Shift‑JIS → UTF‑8 変換を適用 	decoder := transform.NewReader(r, japanese.ShiftJIS.NewDecoder()) 	reader := csv.NewReader(decoder) 	records, err := reader.ReadAll() 	if err != nil { 		return nil, err 	} 	taniMap := make(map[string]string) 	for _, row := range records { 		if len(row) < 2 { 			log.Printf("TANI行のフィールド不足: %v", row) 			continue 		} 		code := row[0] 		unit := row[1] 		taniMap[code] = unit 	} 	return taniMap, nil }

----- C:\Dev\YAMATO\usage\usage.go -----
package usage  import ( 	"bufio" 	"io" 	"log" 	"os" 	"strings"  	"YAMATO/ma0" 	"YAMATO/tani"  	"golang.org/x/text/encoding/japanese" 	"golang.org/x/text/transform" )  // UsageRecord は USAGE CSV の各レコード情報を保持します。 type UsageRecord struct { 	UsageDate        string `json:"usageDate"`        // 使用日 	UsageYjCode      string `json:"usageYjCode"`      // YJコード（以前の UsageCode） 	UsageJanCode     string `json:"usageJanCode"`     // JANコード（以前の JANCode） 	UsageProductName string `json:"usageProductName"` // 商品名（以前の ProductName） 	UsageAmount      string `json:"usageAmount"`      // 数量／金額（以前の QuantityOrAmount） 	UsageUnit        string `json:"usageUnit"`        // 単位コード（以前の Unit） 	UsageUnitName    string `json:"usageUnitName"`    // 単位名称（以前の UnitName → TANI マスターから取得） }  // taniMap は TANI マスターのデータを保持するグローバル変数です。 var taniMap map[string]string  // loadTaniMap は、所定のパスから TANI.CSV を読み込み、 taniMap にセットします。 func loadTaniMap() { 	if taniMap != nil { 		return 	} 	// TANI.CSV のパス。各環境に合わせて修正してください。 	f, err := os.Open("C:\\Dev\\YAMATO\\SOU\\TANI.CSV") 	if err != nil { 		log.Printf("TANIファイルオープンエラー: %v", err) 		taniMap = make(map[string]string) 		return 	} 	defer f.Close() 	tMap, err := tani.ParseTANI(f) 	if err != nil { 		log.Printf("TANIパース失敗: %v", err) 		taniMap = make(map[string]string) 		return 	} 	taniMap = tMap }  // ParseUsageFile は、USAGE CSV をパースして動作情報を UsageRecord として返します。 // USAGE CSV は Shift‑JIS でエンコードされているため変換を適用し、最初のヘッダー行をスキップして各行を処理します。 func ParseUsageFile(r io.Reader) ([]UsageRecord, error) { 	loadTaniMap()  	var records []UsageRecord 	scanner := bufio.NewScanner(transform.NewReader(r, japanese.ShiftJIS.NewDecoder())) 	headerSkipped := false 	for scanner.Scan() { 		line := scanner.Text() 		// ヘッダー行（"UsageDate" を含む場合）をスキップ 		if !headerSkipped { 			if strings.Contains(line, "UsageDate") { 				headerSkipped = true 				continue 			} 			headerSkipped = true 		} 		// カンマ区切りで分割 		fields := strings.Split(line, ",") 		if len(fields) < 6 { 			continue 		} 		// 各フィールドの前後の引用符や空白を除去 		for i, f := range fields { 			fields[i] = strings.Trim(f, "\" ") 		} 		// 仮のフィールド配置（実際は仕様に合わせて調整してください）： 		// fields[0]: 使用日, [1]: YJコード, [2]: JANコード, [3]: 商品名, [4]: 数量／金額, [5]: 単位コード 		ur := UsageRecord{ 			UsageDate:        fields[0], 			UsageYjCode:      fields[1], 			UsageJanCode:     fields[2], 			UsageProductName: fields[3], 			UsageAmount:      fields[4], 			UsageUnit:        fields[5], 		} 		// TANI マスターから、単位コードに対応する単位名称を取得 		if name, ok := taniMap[ur.UsageUnit]; ok { 			ur.UsageUnitName = name 		} else { 			ur.UsageUnitName = ur.UsageUnit 		} 		records = append(records, ur)  		// MA0 照合処理：UsageRecord の JANコード（UsageJanCode）をキーとしてチェック 		_, created, err := ma0.CheckOrCreateMA0(ur.UsageJanCode) 		if err != nil { 			log.Printf("[USAGE] MA0照合エラー (JAN=%q): %v", ur.UsageJanCode, err) 		} else if created { 			log.Printf("[USAGE] 新規MA0登録: %q", ur.UsageJanCode) 		} 	} 	if err := scanner.Err(); err != nil { 		return nil, err 	} 	return records, nil }

----- C:\Dev\YAMATO\main.go -----
package main  import ( 	"database/sql" 	"encoding/csv" 	"encoding/json" 	"io" 	"log" 	"net/http" 	"os" 	"os/exec" 	"runtime" 	"strings"  	_ "github.com/mattn/go-sqlite3"  	"YAMATO/dat" 	"YAMATO/ma0" 	"YAMATO/usage" )  var db *sql.DB  // uploadDatHandler は既存のまま func uploadDatHandler(w http.ResponseWriter, r *http.Request) { 	if r.Method != http.MethodPost { 		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed) 		return 	} 	err := r.ParseMultipartForm(10 << 20) 	if err != nil { 		http.Error(w, "Error parsing form: "+err.Error(), http.StatusBadRequest) 		return 	} 	files := r.MultipartForm.File["datFileInput[]"] 	if len(files) == 0 { 		http.Error(w, "No DAT file uploaded", http.StatusBadRequest) 		return 	}  	var allRecords []dat.DATRecord 	totalCount, ma0CreatedCount, duplicateCount := 0, 0, 0 	for _, fileHeader := range files { 		file, err := fileHeader.Open() 		if err != nil { 			log.Println("Error opening DAT file:", err) 			continue 		} 		defer file.Close()  		records, tc, mc, dc, err := dat.ParseDATFile(file) 		if err != nil { 			log.Println("Error parsing DAT file:", err) 			continue 		} 		totalCount += tc 		ma0CreatedCount += mc 		duplicateCount += dc 		allRecords = append(allRecords, records...) 	}  	resp := map[string]interface{}{ 		"DATReadCount":    totalCount, 		"MA0CreatedCount": ma0CreatedCount, 		"DuplicateCount":  duplicateCount, 		"DATRecords":      allRecords, 	} 	w.Header().Set("Content-Type", "application/json") 	json.NewEncoder(w).Encode(resp) }  // uploadUsageHandler は既存のまま func uploadUsageHandler(w http.ResponseWriter, r *http.Request) { 	if r.Method != http.MethodPost { 		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed) 		return 	} 	err := r.ParseMultipartForm(10 << 20) 	if err != nil { 		http.Error(w, "Error parsing form: "+err.Error(), http.StatusBadRequest) 		return 	} 	files := r.MultipartForm.File["usageFileInput[]"] 	if len(files) == 0 { 		http.Error(w, "No USAGE file uploaded", http.StatusBadRequest) 		return 	} 	var allRecords []usage.UsageRecord 	for _, fileHeader := range files { 		file, err := fileHeader.Open() 		if err != nil { 			log.Println("Error opening USAGE file:", err) 			continue 		} 		defer file.Close() 		records, err := usage.ParseUsageFile(file) 		if err != nil { 			log.Println("Error parsing USAGE file:", err) 			continue 		} 		allRecords = append(allRecords, records...) 	} 	w.Header().Set("Content-Type", "application/json") 	json.NewEncoder(w).Encode(map[string]interface{}{ 		"USAGERecords": allRecords, 		"TotalRecords": len(allRecords), 	}) }  // viewMA0Handler は既存のまま func viewMA0Handler(w http.ResponseWriter, r *http.Request) { 	ma0.ViewMA0Handler(w, r) }  // autoLaunchBrowser は既存のまま func autoLaunchBrowser(url string) { 	var cmd string 	var args []string 	switch runtime.GOOS { 	case "windows": 		cmd = "cmd" 		args = []string{"/c", "start", url} 	case "darwin": 		cmd = "open" 		args = []string{url} 	default: 		cmd = "xdg-open" 		args = []string{url} 	} 	if err := exec.Command(cmd, args...).Start(); err != nil { 		log.Printf("Browser auto-launch failed: %v", err) 	} }  // loadCSV は起動時の JCHMAS/JANCODE 一括取り込み用 func loadCSV(db *sql.DB, filePath, table string, cols int) error { 	f, err := os.Open(filePath) 	if err != nil { 		return err 	} 	defer f.Close()  	r := csv.NewReader(f) 	// ヘッダー行をスキップ 	if _, err := r.Read(); err != nil { 		return err 	}  	tx, err := db.Begin() 	if err != nil { 		return err 	} 	// プレースホルダーを作成 	ph := make([]string, cols) 	for i := range ph { 		ph[i] = "?" 	} 	stmt, err := tx.Prepare( 		"INSERT OR REPLACE INTO " + table + 			" VALUES(" + strings.Join(ph, ",") + ")", 	) 	if err != nil { 		return err 	} 	defer stmt.Close()  	for { 		rec, err := r.Read() 		if err == io.EOF { 			break 		} 		if err != nil { 			tx.Rollback() 			return err 		} 		args := make([]interface{}, len(rec)) 		for i, v := range rec { 			args[i] = v 		} 		if _, err := stmt.Exec(args...); err != nil { 			tx.Rollback() 			return err 		} 	} 	return tx.Commit() }  func main() { 	var err error  	// ① DB を開く 	db, err = sql.Open("sqlite3", "yamato.db") 	if err != nil { 		log.Fatalf("DB open error: %v", err) 	} 	defer db.Close()  	// ② schema.sql を読み込んでテーブル定義を反映（IF NOT EXISTS を schema.sql に記述） 	b, err := os.ReadFile("schema.sql") 	if err != nil { 		log.Fatalf("Failed to read schema.sql: %v", err) 	} 	if _, err := db.Exec(string(b)); err != nil { 		log.Fatalf("Failed to exec schema.sql: %v", err) 	}  	// ③ SOUフォルダの JCHMAS/JANCODE CSV を毎回取り込み 	jchmasPath := `C:\Dev\YAMATO\SOU\JCSHMS.CSV` 	jancodePath := `C:\Dev\YAMATO\SOU\JANCODE.CSV` 	if err := loadCSV(db, jchmasPath, "jchmas", 125); err != nil { 		log.Fatalf("failed to load %s: %v", jchmasPath, err) 	} 	if err := loadCSV(db, jancodePath, "jancode", 30); err != nil { 		log.Fatalf("failed to load %s: %v", jancodePath, err) 	}  	// ④ HTTP サーバーの既存処理 	fs := http.FileServer(http.Dir("./static")) 	http.Handle("/", fs) 	http.HandleFunc("/uploadDat", uploadDatHandler) 	http.HandleFunc("/uploadUsage", uploadUsageHandler) 	http.HandleFunc("/viewMA0", viewMA0Handler)  	go autoLaunchBrowser("http://localhost:8080") 	log.Println("Server starting on port :8080") 	if err := http.ListenAndServe(":8080", nil); err != nil { 		log.Fatal("ListenAndServe:", err) 	} }

