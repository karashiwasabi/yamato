----- C:\Dev\YAMATO\dat\dat.go -----
// File: dat/dat.go package dat  import ( 	"bufio" 	"io" 	"log" 	"strings"  	"golang.org/x/text/encoding/japanese" 	"golang.org/x/text/transform"  	"YAMATO/ma0" )  // DATRecord は DAT ファイルの1行をパースした結果を保持します。 type DATRecord struct { 	DatOroshiCode         string // S行の卸コード 	DatDate               string // D行の日付 	DatDeliveryFlag       string // D行のデリバリフラグ 	DatReceiptNumber      string // D行の受領番号 	DatLineNumber         string // D行の行番号 	DatJanCode            string // D行のJANコード 	DatProductName        string // D行の商品名 	DatQuantity           string // D行の数量 	DatUnitPrice          string // D行の単価 	DatSubtotal           string // D行の小計 	DatPackagingDrugPrice string // D行の包装医薬品価格 	DatExpiryDate         string // D行の賞味期限 	DatLotNumber          string // D行のロット番号 }  // ProcessDATRecord は、スライス化したレコードデータで MA0 を作成／参照します。 func ProcessDATRecord(data []string) (bool, error) { 	if len(data) < 5 { 		return false, nil 	} 	jan := data[4] 	_, created, err := ma0.CheckOrCreateMA0(jan) 	if err != nil { 		return false, err 	} 	if created { 		log.Printf("[DAT] New MA0 record: JAN=%q", jan) 	} 	return created, nil }  // ParseDATFile は io.Reader から DAT を読み込み、各レコードを DATRecord にして返します。 // 同時に ProcessDATRecord で MA0 の登録も行い、件数も集計します。 func ParseDATFile(r io.Reader) (records []DATRecord, totalCount, ma0CreatedCount, duplicateCount int, err error) { 	scanner := bufio.NewScanner(r) 	var currentOroshiCode string  	for scanner.Scan() { 		line := scanner.Text() 		if len(line) < 3 { 			continue 		} 		if strings.HasPrefix(line, "S20") { 			currentOroshiCode = strings.TrimSpace(line[3:14]) 			continue 		} 		if !strings.HasPrefix(line, "D20") { 			continue 		} 		totalCount++  		// フィールド抽出 		get := func(s string, start, end int) string { 			if len(s) >= end { 				return s[start:end] 			} else if len(s) > start { 				return s[start:] 			} 			return "" 		} 		datDate := get(line, 4, 12) 		datFlag := get(line, 3, 4) 		datRecNo := get(line, 12, 22) 		datLineNo := get(line, 22, 24) 		datJan := get(line, 25, 38) 		rawName := get(line, 38, 78) 		name, _, convErr := transform.String(japanese.ShiftJIS.NewDecoder(), rawName) 		if convErr != nil { 			name = rawName 		} 		datQty := get(line, 78, 83) 		datUnit := get(line, 83, 92) 		datSub := get(line, 92, 101) 		datPkg := get(line, 101, 109) 		datExp := get(line, 109, 115) 		datLot := get(line, 115, 121)  		rec := DATRecord{ 			DatOroshiCode:         currentOroshiCode, 			DatDate:               datDate, 			DatDeliveryFlag:       datFlag, 			DatReceiptNumber:      datRecNo, 			DatLineNumber:         datLineNo, 			DatJanCode:            datJan, 			DatProductName:        name, 			DatQuantity:           datQty, 			DatUnitPrice:          datUnit, 			DatSubtotal:           datSub, 			DatPackagingDrugPrice: datPkg, 			DatExpiryDate:         datExp, 			DatLotNumber:          datLot, 		} 		records = append(records, rec)  		// MA0連携 		created, procErr := ProcessDATRecord([]string{ 			currentOroshiCode, 			datDate, 			datFlag, 			datRecNo, 			datJan, 			datLineNo, 			name, 			datQty, 			datUnit, 			datSub, 			datPkg, 			datExp, 			datLot, 		}) 		if procErr != nil { 			return records, totalCount, ma0CreatedCount, duplicateCount, procErr 		} 		if created { 			ma0CreatedCount++ 		} else { 			duplicateCount++ 		} 	} 	if scanErr := scanner.Err(); scanErr != nil { 		err = scanErr 	} 	return }

----- C:\Dev\YAMATO\jancode\jancode.go -----
// File: jancode/jancode.go package jancode  import ( 	"database/sql" 	"fmt" )  type JANCODERecord struct { 	JA001                      string 	JA002JanCode               string 	JA003                      string 	JA004                      string 	JA005                      string 	JA006                      string 	JA007HousouSuuryouSuuchi   string 	JA008HousouSuuryouTaniCode string 	JA009HousouSouryouSuuchi   string 	JA010                      string 	JA011                      string 	JA012                      string 	JA013                      string 	JA014                      string 	JA015                      string 	JA016                      string 	JA017                      string 	JA018                      string 	JA019                      string 	JA020                      string 	JA021                      string 	JA022                      string 	JA023                      string 	JA024                      string 	JA025                      string 	JA026                      string 	JA027                      string 	JA028                      string 	JA029                      string 	JA030                      string }  func QueryJANCODERecordsByJan(db *sql.DB, jan string) ([]JANCODERecord, error) { 	query := `         SELECT  JA001, JA002JanCode, JA003, JA004, JA005, JA006, JA007HousouSuuryouSuuchi, JA008HousouSuuryouTaniCode, JA009HousouSouryouSuuchi, JA010, JA011, JA012, JA013, JA014, JA015, JA016, JA017, JA018, JA019, JA020, JA021, JA022, JA023, JA024, JA025, JA026, JA027, JA028, JA029, JA030         FROM jancode         WHERE JA002JanCode = ?     ` 	rows, err := db.Query(query, jan) 	if err != nil { 		return nil, fmt.Errorf("jancode query error: %v", err) 	} 	defer rows.Close()  	var records []JANCODERecord 	for rows.Next() { 		var rec JANCODERecord 		if err := rows.Scan(&rec.JA002JanCode, &rec.JA007HousouSuuryouSuuchi); err != nil { 			return nil, fmt.Errorf("jancode row scan error: %v", err) 		} 		records = append(records, rec) 	} 	if err := rows.Err(); err != nil { 		return nil, fmt.Errorf("jancode rows error: %v", err) 	} 	return records, nil }

----- C:\Dev\YAMATO\jchms\jchms.go -----
// File: jchms/jchms.go package jchms  import ( 	"database/sql" 	"fmt" 	"reflect" )  // JCFields holds 125 columns from the JCHMAS CSV. // CSV取り込み時、テーブル jchmas の列は「JC000JanCode, JC001, JC002, …, JC124」として保存される前提です。 type JCFields struct { 	JC000JanCode                           string 	JC001JanCodeShikibetsuKubun            string 	JC002KyuuJanCode                       string 	JC003TouitsuShouhinCode                string 	JC004YakkaKijunShuusaiIyakuhinCode     string 	JC005KyuuYakkaKijunShuusaiIyakuhinCode string 	JC006HOTBangou                         string 	JC007ReseputoCode1                     string 	JC008ReseputoCode2                     string 	JC009YJCode                            string 	JC010YakkouBunruiCode                  string 	JC011YakkouBunruiMei                   string 	JC012ShiyouKubunCode                   string 	JC013ShiyouKubunMeishou                string 	JC014NihonHyoujunShouhinBunruiBangou   string 	JC015ZaikeiCode                        string 	JC016ZaikeiKigou                       string 	JC017ZaikeiMeishou                     string 	JC018ShouhinMei                        string 	JC019HankakuShouhinMei                 string 	JC020KikakuYouryou                     string 	JC021HankakuKikakuYouryou              string 	JC022ShouhinMeiKanaSortYou             string 	JC023ShouhinMeiKanpouYouKigou          string 	JC024IppanMeishou                      string 	JC025YakkaShuusaiMeishou               string 	JC026ReseYouIyakuhinMei                string 	JC027KikakuTaniMeishou                 string 	JC028KikakuTaniKigou                   string 	JC029HanbaiMotoCode                    string 	JC030HanbaiMotoMei                     string 	JC031HanbaiMotoMeiKana                 string 	JC032HanbaiMotoMeiRyakuMei             string 	JC033SeizouMotoYunyuuMotoCode          string 	JC034SeizouMotoYunyuuMotoMei           string 	JC035SeizouMotoYunyuuMotoMeiKana       string 	JC036SeizouMotoYunyuuMotoMeiRyakuMei   string 	JC037HousouKeitai                      string 	JC038HousouTaniSuuchi                  string 	JC039HousouTaniTani                    string 	JC040HousouSuuryouSuuchi               string 	JC041HousouSuuryouTani                 string 	JC042HousouIrisuuSuuchi                string 	JC043HousouIrisuuTani                  string 	JC044HousouSouryouSuuchi               string 	JC045HousouSouryouTani                 string 	JC046HousouYouryouSuuchi               string 	JC047HousouYouryouTani                 string 	JC048HousouYakkaKeisuu                 string 	JC049GenTaniYakka                      string 	JC050GenHousouYakka                    string 	JC051KyuuTaniYakka                     string 	JC052KyuuHousouYakka                   string 	JC053KokuchiTaniYakka                  string 	JC054KokuchiHousouYakka                string 	JC055YakkaKaiteiNengappi               string 	JC056YakkaShuusaiNengappi              string 	JC057HanbaiKaishiNengappi              string 	JC058KeikaSochiNengappi                string 	JC059HatsubaiChuushiNengappi           string 	JC060SeizouChuushiNengappi             string 	JC061Doyaku                            string 	JC062Gekiyaku                          string 	JC063Mayaku                            string 	JC064Kouseishinyaku                    string 	JC065Kakuseizai                        string 	JC066KakuseizaiGenryou                 string 	JC067ShuukanseiIyakuhin                string 	JC068ShiteiIyakuhinKyuuKiseiKubun      string 	JC069YoushijiIyakuhinKyuuKiseiKubun    string 	JC070KetsuekiSeizai                    string 	JC071NihonYakkyokuhou                  string 	JC072YuukouKikan                       string 	JC073ShiyouKigen                       string 	JC074SeibutsuYuraiSeihin               string 	JC075Kouhatsuhin                       string 	JC076YakkaKijunShuusaiKubun            string 	JC077KichouGimuKubun                   string 	JC078ShouhinKubun                      string 	JC079ShohousenIyakuhin                 string 	JC080ChuushiRiyuuKubun                 string 	JC081MishiyouKyuuRyuutsuuKanrihin      string 	JC082MentenanceKubun                   string 	JC083KouhatsuhinNoAruSenpatsuhinKubun  string 	JC084AuthorizedGeneric                 string 	JC085Biosimilar                        string 	JC086HighRiskYaku                      string 	JC087Kuuran1                           string 	JC088Kuuran2                           string 	JC089Shitsuon                          string 	JC090Reisho                            string 	JC091Reizou                            string 	JC092Reitou                            string 	JC093Ansho                             string 	JC094Shakou                            string 	JC095KimitsuYouki                      string 	JC096MippuuYouki                       string 	JC097Kikenbutsu                        string 	JC098OndoJougen                        string 	JC099OndoKagen                         string 	JC100SonotaHokanjouNoChui              string 	JC101KonpouJuuryouSizeJouhou           string 	JC102KonpouTateSizeJouhou              string 	JC103KonpouYokoSizeJouhou              string 	JC104KonpouTakasaSizeJouhou            string 	JC105KonpouTaiseiSizeJouhou            string 	JC106ChuubakoJuuryouSizeJouhou         string 	JC107ChuubakoTateSizeJouhou            string 	JC108ChuubakoYokoSizeJouhou            string 	JC109ChuubakoTakasaSizeJouhou          string 	JC110ChuubakoTaiseiSizeJouhou          string 	JC111KousouJuuryouSizeJouhou           string 	JC112KousouTateSizeJouhou              string 	JC113KousouYokoSizeJouhou              string 	JC114KousouTakasaSizeJouhou            string 	JC115KousouTaiseiSizeJouhou            string 	JC116KonpouTaniSizeJouhou              string 	JC117HacchuuTaniSizeJouhou             string 	JC118KoushinKubun                      string 	JC119TourokuNengappi                   string 	JC120KoushinNengappi                   string 	JC121ChouzaiHousouTaniCode             string 	JC122HanbaiHousouTaniCode              string 	JC123IppanMeiKana                      string 	JC124SaishouYakkaKansanKeisuu          string }  // JCHMASRecord represents one record in table jchmas. type JCHMASRecord struct { 	// JANCode は、SELECT 文で「JC000JanCode AS JC000」により取得された値です。 	JC000JanCode string 	// JC は、CSVの125フィールドを保持します。 	JC JCFields }  // QueryJCHMASRecordsByJan queries the jchmas table for records matching the JAN code. // SELECT 句では、列「JC000JanCode」をエイリアス「JC000」として取得します。 func QueryJCHMASRecordsByJan(db *sql.DB, jan string) ([]JCHMASRecord, error) { 	query := `         SELECT  JC000JanCode, JC001JanCodeShikibetsuKubun, JC002KyuuJanCode, JC003TouitsuShouhinCode, JC004YakkaKijunShuusaiIyakuhinCode, JC005KyuuYakkaKijunShuusaiIyakuhinCode, JC006HOTBangou, JC007ReseputoCode1, JC008ReseputoCode2, JC009YJCode, JC010YakkouBunruiCode, JC011YakkouBunruiMei, JC012ShiyouKubunCode, JC013ShiyouKubunMeishou, JC014NihonHyoujunShouhinBunruiBangou, JC015ZaikeiCode, JC016ZaikeiKigou, JC017ZaikeiMeishou, JC018ShouhinMei, JC019HankakuShouhinMei, JC020KikakuYouryou, JC021HankakuKikakuYouryou, JC022ShouhinMeiKanaSortYou, JC023ShouhinMeiKanpouYouKigou, JC024IppanMeishou, JC025YakkaShuusaiMeishou, JC026ReseYouIyakuhinMei, JC027KikakuTaniMeishou, JC028KikakuTaniKigou, JC029HanbaiMotoCode, JC030HanbaiMotoMei, JC031HanbaiMotoMeiKana, JC032HanbaiMotoMeiRyakuMei, JC033SeizouMotoYunyuuMotoCode, JC034SeizouMotoYunyuuMotoMei, JC035SeizouMotoYunyuuMotoMeiKana, JC036SeizouMotoYunyuuMotoMeiRyakuMei, JC037HousouKeitai, JC038HousouTaniSuuchi, JC039HousouTaniTani, JC040HousouSuuryouSuuchi, JC041HousouSuuryouTani, JC042HousouIrisuuSuuchi, JC043HousouIrisuuTani, JC044HousouSouryouSuuchi, JC045HousouSouryouTani, JC046HousouYouryouSuuchi, JC047HousouYouryouTani, JC048HousouYakkaKeisuu, JC049GenTaniYakka, JC050GenHousouYakka, JC051KyuuTaniYakka, JC052KyuuHousouYakka, JC053KokuchiTaniYakka, JC054KokuchiHousouYakka, JC055YakkaKaiteiNengappi, JC056YakkaShuusaiNengappi, JC057HanbaiKaishiNengappi, JC058KeikaSochiNengappi, JC059HatsubaiChuushiNengappi, JC060SeizouChuushiNengappi, JC061Doyaku, JC062Gekiyaku, JC063Mayaku, JC064Kouseishinyaku, JC065Kakuseizai, JC066KakuseizaiGenryou, JC067ShuukanseiIyakuhin, JC068ShiteiIyakuhinKyuuKiseiKubun, JC069YoushijiIyakuhinKyuuKiseiKubun, JC070KetsuekiSeizai, JC071NihonYakkyokuhou, JC072YuukouKikan, JC073ShiyouKigen, JC074SeibutsuYuraiSeihin, JC075Kouhatsuhin, JC076YakkaKijunShuusaiKubun, JC077KichouGimuKubun, JC078ShouhinKubun, JC079ShohousenIyakuhin, JC080ChuushiRiyuuKubun, JC081MishiyouKyuuRyuutsuuKanrihin, JC082MentenanceKubun, JC083KouhatsuhinNoAruSenpatsuhinKubun, JC084AuthorizedGeneric, JC085Biosimilar, JC086HighRiskYaku, JC087Kuuran1, JC088Kuuran2, JC089Shitsuon, JC090Reisho, JC091Reizou, JC092Reitou, JC093Ansho, JC094Shakou, JC095KimitsuYouki, JC096MippuuYouki, JC097Kikenbutsu, JC098OndoJougen, JC099OndoKagen, JC100SonotaHokanjouNoChui, JC101KonpouJuuryouSizeJouhou, JC102KonpouTateSizeJouhou, JC103KonpouYokoSizeJouhou, JC104KonpouTakasaSizeJouhou, JC105KonpouTaiseiSizeJouhou, JC106ChuubakoJuuryouSizeJouhou, JC107ChuubakoTateSizeJouhou, JC108ChuubakoYokoSizeJouhou, JC109ChuubakoTakasaSizeJouhou, JC110ChuubakoTaiseiSizeJouhou, JC111KousouJuuryouSizeJouhou, JC112KousouTateSizeJouhou, JC113KousouYokoSizeJouhou, JC114KousouTakasaSizeJouhou, JC115KousouTaiseiSizeJouhou, JC116KonpouTaniSizeJouhou, JC117HacchuuTaniSizeJouhou, JC118KoushinKubun, JC119TourokuNengappi, JC120KoushinNengappi, JC121ChouzaiHousouTaniCode, JC122HanbaiHousouTaniCode, JC123IppanMeiKana, JC124SaishouYakkaKansanKeisuu         FROM jchmas         WHERE JC000JanCode = ?     ` 	rows, err := db.Query(query, jan) 	if err != nil { 		return nil, fmt.Errorf("jchmas query error: %v", err) 	} 	defer rows.Close()  	const colsCount = 125 	var records []JCHMASRecord 	for rows.Next() { 		columns := make([]interface{}, colsCount) 		columnPtrs := make([]interface{}, colsCount) 		for i := 0; i < colsCount; i++ { 			columnPtrs[i] = &columns[i] 		} 		if err := rows.Scan(columnPtrs...); err != nil { 			return nil, fmt.Errorf("jchmas scan error: %v", err) 		}  		var rec JCHMASRecord 		// 最初のカラム（エイリアス済みの JC000）を JANCode として取得 		if b, ok := columns[0].([]byte); ok { 			rec.JC000JanCode = string(b) 		} else if columns[0] != nil { 			rec.JC000JanCode = columns[0].(string) 		}  		var jf JCFields 		jfVal := reflect.ValueOf(&jf).Elem() 		for i := 0; i < colsCount; i++ { 			var colStr string 			if b, ok := columns[i].([]byte); ok { 				colStr = string(b) 			} else if columns[i] != nil { 				colStr = columns[i].(string) 			} 			if i < jfVal.NumField() && jfVal.Field(i).CanSet() { 				jfVal.Field(i).SetString(colStr) 			} else { 				return nil, fmt.Errorf("failed to set JCFields field index %d", i) 			} 		} 		rec.JC = jf 		records = append(records, rec) 	} 	if err := rows.Err(); err != nil { 		return nil, fmt.Errorf("jchmas rows error: %v", err) 	} 	return records, nil }

----- C:\Dev\YAMATO\js\dat.js -----
document.addEventListener('DOMContentLoaded', () => {   const uploadBtn = document.getElementById('uploadBtn');   const fileInput = document.getElementById('fileInput');   const indicator = document.getElementById('indicator');   const output = document.getElementById('output');    if (!uploadBtn || !fileInput || !indicator || !output) {     console.error("必要な DOM 要素が見つかりません。HTML を確認してください。");     return;   }    // アップロードボタンをクリックでファイル選択ダイアログを表示   uploadBtn.addEventListener('click', () => {     fileInput.click();   });    fileInput.addEventListener('change', async () => {     const files = fileInput.files;     if (!files || files.length === 0) {       console.warn("ファイルが選択されていません。");       return;     }      // Indicator に選択されたファイル数を表示     indicator.textContent = `${files.length} 個のファイルが選択されました。`;      let results = [];     // 各ファイルを1個ずつアップロード     for (let i = 0; i < files.length; i++) {       const formData = new FormData();       formData.append('file', files[i]);        try {         const res = await fetch('/upload', {           method: 'POST',           body: formData         });         if (!res.ok) throw new Error(`HTTPエラー: ${res.status}`);         // レスポンスはプレーンテキストとして受け取る         const text = await res.text();         results.push(`[${files[i].name}]:\n${text}`);       } catch (err) {         results.push(`[${files[i].name}]: アップロード失敗 (${err.message})`);       }     }     output.textContent = results.join("\n\n");     indicator.textContent += " アップロード処理が完了しました。";     fileInput.value = '';   }); });

----- C:\Dev\YAMATO\ma0\mao.go -----
// File: ma0/ma0.go package ma0  import ( 	"database/sql" 	"encoding/json" 	"fmt" 	"net/http" 	"sync"  	"YAMATO/jancode" 	"YAMATO/jchms" )  type MA0Record struct { 	MA000JC000JanCode             string `json:"mA000JC000JanCode"` 	MA009JC009YJCode              string `json:"mA009JC009YJCode"` 	MA131JA007HousouSuuryouSuuchi string `json:"mA131JA007HousouSuuryouSuuchi"` }  var ( 	DB     *sql.DB 	cache  = make(map[string]MA0Record) 	cacheM sync.Mutex )  // CheckOrCreateMA0 はキャッシュ→DB→マスター照会→INSERT を行います。 func CheckOrCreateMA0(jan string) (MA0Record, bool, error) { 	cacheM.Lock() 	defer cacheM.Unlock()  	if rec, ok := cache[jan]; ok { 		return rec, false, nil 	} 	// DB検索 	var rec MA0Record 	err := DB.QueryRow(`         SELECT             MA000JC000JanCode,             MA009JC009YJCode,             MA131JA007HousouSuuryouSuuchi         FROM ma0         WHERE MA000JC000JanCode = ?     `, jan).Scan( 		&rec.MA000JC000JanCode, 		&rec.MA009JC009YJCode, 		&rec.MA131JA007HousouSuuryouSuuchi, 	) 	if err == nil { 		cache[jan] = rec 		return rec, false, nil 	} 	if err != sql.ErrNoRows { 		return MA0Record{}, false, err 	}  	// マスター照会 	jcRecs, _ := jchms.QueryJCHMASRecordsByJan(DB, jan) 	jaRecs, _ := jancode.QueryJANCODERecordsByJan(DB, jan) 	var yj, t string 	if len(jcRecs) > 0 { 		yj = jcRecs[0].JC.JC009YJCode 	} 	if len(jaRecs) > 0 { 		t = jaRecs[1].JA007HousouSuuryouSuuchi 	} 	newRec := MA0Record{jan, yj, t}  	if _, err := DB.Exec(`         INSERT INTO ma0 (             MA000JC000JanCode,             MA009JC009YJCode,             MA131JA007HousouSuuryouSuuchi         ) VALUES (?, ?, ?)     `, jan, yj, t); err != nil { 		return MA0Record{}, false, err 	} 	cache[jan] = newRec 	return newRec, true, nil }  // ProcessMA0Record は DAT レコードを受け取り、Create時だけ出力します。 func ProcessMA0Record(data []string) error { 	if len(data) < 3 { 		return fmt.Errorf("insufficient data") 	} 	rec, created, err := CheckOrCreateMA0(data[2]) 	if err != nil { 		return err 	} 	if created { 		fmt.Printf("New MA0 created: %+v\n", rec) 	} 	return nil }  // ViewMA0Handler はキャッシュ全件を JSON で返します。 func ViewMA0Handler(w http.ResponseWriter, r *http.Request) { 	cacheM.Lock() 	defer cacheM.Unlock() 	list := make([]MA0Record, 0, len(cache)) 	for _, v := range cache { 		list = append(list, v) 	} 	w.Header().Set("Content-Type", "application/json; charset=utf-8") 	json.NewEncoder(w).Encode(list) }  func CountMA0() (int, error) { 	var cnt int 	err := DB.QueryRow("SELECT COUNT(*) FROM ma0").Scan(&cnt) 	return cnt, err }

----- C:\Dev\YAMATO\static\css\styles.css -----
body {   font-family: Arial, sans-serif;   margin: 1em; } header button {   margin-right: .5em;   padding: .4em 1em; } #indicator {   margin: 1em 0;   font-weight: bold; } #outputTable {   width: 100%;   border-collapse: collapse; } #outputTable th, #outputTable td {   border: 1px solid #ccc;   padding: .3em .6em;   font-size: .85em; } #outputTable th {   background: #f0f0f0;   text-align: left; }

----- C:\Dev\YAMATO\static\js\dat.js -----
document.addEventListener('DOMContentLoaded', () => {   // 各DOM要素の取得   const btn       = document.getElementById('datBtn');   const input     = document.getElementById('datInput');   const indicator = document.getElementById('indicator');   const table     = document.getElementById('outputTable');   const thead     = table.querySelector('thead');   const tbody     = table.querySelector('tbody');    // DATファイルアップロードボタンをクリックで隠しファイル入力をトリガー   btn.addEventListener('click', () => {     input.click();   });    // ファイル選択後の処理   input.addEventListener('change', async () => {     if (!input.files.length) return;      // アップロード開始状態を indicator に表示     indicator.textContent = 'DATアップロード中…';      // テーブルヘッダー、ボディの初期化     thead.innerHTML = `       <tr>         <th>卸コード</th>         <th>日付</th>         <th>納品／返品</th>         <th>伝票番号</th>         <th>行番号</th>         <th>JANコード</th>         <th>商品名</th>         <th>数量</th>         <th>単価</th>         <th>小計</th>         <th>包装薬価</th>         <th>有効期限</th>         <th>ロット番号</th>       </tr>`;     tbody.innerHTML = '';      // 選択された全ファイルについてループ処理     for (let file of input.files) {       const formData = new FormData();       formData.append('datFileInput[]', file);        try {         // /uploadDat エンドポイントに対して POST リクエスト送信         const res = await fetch('/uploadDat', { method: 'POST', body: formData });         if (!res.ok) {           throw new Error(`HTTPステータス: ${res.status}`);         }         // サーバーから返却される JSON を取得（"DATRecords" などのキーを持つ）         const result = await res.json();          // 指定ファイルの処理結果を indicator に表示         indicator.textContent = `${file.name}: DAT読み込み: ${result.DATReadCount} 件 | MA0作成: ${result.MA0CreatedCount} 件 | 重複: ${result.DuplicateCount} 件`;          // DATRecords に含まれる各レコードをテーブルへ追加         if (result.DATRecords && result.DATRecords.length > 0) {           result.DATRecords.forEach(record => {             const tr = document.createElement('tr');             tr.innerHTML = `               <td>${record.DatOroshiCode}</td>               <td>${record.DatDate}</td>               <td>${record.DatDeliveryFlag}</td>               <td>${record.DatReceiptNumber}</td>               <td>${record.DatLineNumber}</td>               <td>${record.DatJanCode}</td>               <td>${record.DatProductName}</td>               <td>${record.DatQuantity}</td>               <td>${record.DatUnitPrice}</td>               <td>${record.DatSubtotal}</td>               <td>${record.DatPackagingDrugPrice}</td>               <td>${record.DatExpiryDate}</td>               <td>${record.DatLotNumber}</td>             `;             tbody.appendChild(tr);           });         }       } catch (err) {         // エラー発生時の処理         indicator.textContent = "アップロード中にエラーが発生しました: " + err.message;         console.error(err);       }     }     // 全ファイル処理完了後のメッセージ     indicator.textContent += " 完了";     // 入力値のリセット     input.value = '';   }); });

----- C:\Dev\YAMATO\static\js\ma0.js -----
document.addEventListener('DOMContentLoaded', () => {   const ma0Btn       = document.getElementById('ma0Btn');   const ma0Container = document.getElementById('ma0Container');   const indicator    = document.getElementById('indicator');    ma0Btn.addEventListener('click', async () => {     indicator.textContent = 'MA0表示中…';     try {       const res = await fetch('/ma0/view');       if (!res.ok) throw new Error(`HTTPステータス: ${res.status}`);        const data = await res.json();       const list = Array.isArray(data) ? data : data.MA0Records || [];        if (list.length > 0) {         ma0Container.innerHTML =           `<h2>MA0レコード（${list.length} 件）</h2>` +           `<ul>` +           list.map(rec =>             `<li>${rec.mA000JC000JanCode} (YJコード: ${rec.mA009JC009YJCode}, 単位コード: ${rec.mA131JA007HousouSuuryouTaniCode})</li>`           ).join('') +           `</ul>`;       } else {         ma0Container.innerHTML = `<h2>MA0は空です。</h2>`;       }     } catch (err) {       // エラー時の表示       indicator.textContent = 'エラーが発生しました: ' + err.message;       console.error(err);     }     // 必要なら finally で完了後の後片付けも可能     // finally {     //   indicator.textContent = '';     // }   }); });

----- C:\Dev\YAMATO\static\js\usage.js -----
document.addEventListener('DOMContentLoaded', () => {   const usageBtn   = document.getElementById('usageBtn');   const usageInput = document.getElementById('usageInput');   const indicator  = document.getElementById('indicator');   const table      = document.getElementById('outputTable');   const thead      = table.querySelector('thead');   const tbody      = table.querySelector('tbody');    usageBtn.addEventListener('click', () => usageInput.click());    usageInput.addEventListener('change', async () => {     if (!usageInput.files || usageInput.files.length === 0) return;      indicator.textContent = 'USAGEアップロード中…';     // 新しいヘッダー（項目名）に合わせて設定     thead.innerHTML = `       <tr>         <th>日付</th>         <th>YJコード</th>         <th>JANコード</th>         <th>商品名</th>         <th>数量</th>         <th>単位コード</th>         <th>単位名称</th>       </tr>`;     tbody.innerHTML = '';      for (let file of usageInput.files) {       const formData = new FormData();       formData.append('usageFileInput[]', file);        try {         const res = await fetch('/uploadUsage', { method: 'POST', body: formData });         if (!res.ok) throw new Error(`HTTPエラー: ${res.status}`);         const result = await res.json();         indicator.textContent = `${file.name}: USAGE読み込み: ${result.TotalRecords} 件`;         if (result.USAGERecords && result.USAGERecords.length > 0) {           result.USAGERecords.forEach(record => {             const tr = document.createElement('tr');             tr.innerHTML = `               <td>${record.usageDate}</td>               <td>${record.usageYjCode}</td>               <td>${record.usageJanCode}</td>               <td>${record.usageProductName}</td>               <td>${record.usageAmount}</td>               <td>${record.usageUnit}</td>               <td>${record.usageUnitName}</td>             `;             tbody.appendChild(tr);           });         }       } catch (error) {         indicator.textContent = "アップロード中にエラー: " + error.message;         console.error("USAGEアップロードエラー:", error);       }     }     indicator.textContent += " 完了";     usageInput.value = '';   }); });

----- C:\Dev\YAMATO\static\index.html -----
<!DOCTYPE html> <html lang="ja"> <head>   <meta charset="UTF-8">   <title>YAMATO Upload</title>   <!-- 必要に応じてスタイルシートを調整 -->   <link rel="stylesheet" href="css/styles.css"> </head> <body>   <header>     <!-- DATファイルアップロードボタン -->     <button id="datBtn">DATファイルアップロード</button>     <!-- USAGEファイルアップロードボタン -->     <button id="usageBtn">USAGEファイルアップロード</button>     <!-- MA0確認ボタン -->     <button id="ma0Btn">MA0確認peropero</button>   </header>      <!-- アップロード処理の進捗や結果を表示するエリア -->   <section id="indicator"></section>      <!-- MA0の中身を表示するエリア -->   <section id="ma0Container"></section>      <!-- 解析結果（必要に応じてテーブル表示） -->   <table id="outputTable">     <thead></thead>     <tbody></tbody>   </table>      <!-- 隠しのファイル入力（DAT/USAGE用） -->   <input type="file" id="datInput" accept=".dat" multiple hidden>   <input type="file" id="usageInput" accept=".csv" multiple hidden>      <!-- JavaScriptファイルの読み込み -->   <script src="js/dat.js"></script>   <script src="js/usage.js"></script>   <script src="js/ma0.js"></script> </body> </html>

----- C:\Dev\YAMATO\tani\tani.go -----
package tani  import ( 	"encoding/csv" 	"io" 	"log"  	"golang.org/x/text/encoding/japanese" 	"golang.org/x/text/transform" )  // ParseTANI は、TANI CSV ファイルを Shift‑JIS から UTF‑8 に変換しながら読み込み、 // 各行のフィールド0（単位コード）をキー、フィールド1（単位名称）を値とするマップを返します。 func ParseTANI(r io.Reader) (map[string]string, error) { 	// Shift‑JIS → UTF‑8 変換を適用 	decoder := transform.NewReader(r, japanese.ShiftJIS.NewDecoder()) 	reader := csv.NewReader(decoder) 	records, err := reader.ReadAll() 	if err != nil { 		return nil, err 	} 	taniMap := make(map[string]string) 	for _, row := range records { 		if len(row) < 2 { 			log.Printf("TANI行のフィールド不足: %v", row) 			continue 		} 		code := row[0] 		unit := row[1] 		taniMap[code] = unit 	} 	return taniMap, nil }

----- C:\Dev\YAMATO\usage\usage.go -----
package usage  import ( 	"bufio" 	"io" 	"log" 	"os" 	"strings"  	"YAMATO/ma0" 	"YAMATO/tani"  	"golang.org/x/text/encoding/japanese" 	"golang.org/x/text/transform" )  // UsageRecord は USAGE CSV の各レコード情報を保持します type UsageRecord struct { 	UsageDate        string `json:"usageDate"` 	UsageYjCode      string `json:"usageYjCode"` 	UsageJanCode     string `json:"usageJanCode"` 	UsageProductName string `json:"usageProductName"` 	UsageAmount      string `json:"usageAmount"` 	UsageUnit        string `json:"usageUnit"` 	UsageUnitName    string `json:"usageUnitName"` }  var taniMap map[string]string  // loadTaniMap は所定のパスの TANI.CSV を読み込み、taniMap にセットします func loadTaniMap() { 	if taniMap != nil { 		return 	} 	f, err := os.Open("C:\\Dev\\YAMATO\\SOU\\TANI.CSV") 	if err != nil { 		log.Printf("TANIファイルオープンエラー: %v", err) 		taniMap = make(map[string]string) 		return 	} 	defer f.Close() 	tMap, err := tani.ParseTANI(f) 	if err != nil { 		log.Printf("TANIパース失敗: %v", err) 		taniMap = make(map[string]string) 		return 	} 	taniMap = tMap }  // ParseUsageFile は、USAGE CSV を Shift‑JIS から UTF‑8 に変換しながらパースして UsageRecord のスライスを返します。 // 各レコードの全データを抽出し、同時に MA0 への連携（全データをそのまま送る）を行います。 func ParseUsageFile(r io.Reader) ([]UsageRecord, error) { 	loadTaniMap() 	var records []UsageRecord 	scanner := bufio.NewScanner(transform.NewReader(r, japanese.ShiftJIS.NewDecoder())) 	headerSkipped := false 	for scanner.Scan() { 		line := scanner.Text()  		// ヘッダー行（"UsageDate" を含む場合）をスキップ 		if !headerSkipped { 			if strings.Contains(line, "UsageDate") { 				headerSkipped = true 				continue 			} 			headerSkipped = true 		}  		// カンマ区切りで各フィールドを取得 		fields := strings.Split(line, ",") 		if len(fields) < 6 { 			continue 		} 		// 各フィールドの前後の引用符や空白を除去 		for i, f := range fields { 			fields[i] = strings.Trim(f, "\" ") 		}  		ur := UsageRecord{ 			UsageDate:        fields[0], 			UsageYjCode:      fields[1], 			UsageJanCode:     fields[2], 			UsageProductName: fields[3], 			UsageAmount:      fields[4], 			UsageUnit:        fields[5], 		} 		// TANI マスターより単位コードに対応する単位名称を取得 		if name, ok := taniMap[ur.UsageUnit]; ok { 			ur.UsageUnitName = name 		} else { 			ur.UsageUnitName = ur.UsageUnit 		}  		records = append(records, ur)  		// ここで UsageRecord の全データをスライスにまとめ、ma0 へそのまま送ります 		recordData := []string{ 			ur.UsageDate,        // 0: 使用日 			ur.UsageYjCode,      // 1: YJコード 			ur.UsageJanCode,     // 2: JANコード ← MA0 のキーとなります 			ur.UsageProductName, // 3: 商品名 			ur.UsageAmount,      // 4: 数量／金額 			ur.UsageUnit,        // 5: 単位コード 			ur.UsageUnitName,    // 6: 単位名称 		} 		if err := ma0.ProcessMA0Record(recordData); err != nil { 			log.Printf("[USAGE] MA0照合エラー (JAN=%q): %v", ur.UsageJanCode, err) 		} 	} 	if err := scanner.Err(); err != nil { 		return nil, err 	} 	return records, nil }

----- C:\Dev\YAMATO\main.go -----
// File: main.go package main  import ( 	"database/sql" 	"encoding/csv" 	"encoding/json" 	"io" 	"log" 	"net/http" 	"os" 	"os/exec" 	"runtime" 	"strings"  	"golang.org/x/text/encoding/japanese" 	"golang.org/x/text/transform"  	"YAMATO/dat" 	"YAMATO/ma0" 	"YAMATO/usage"  	_ "github.com/mattn/go-sqlite3" )  // loadCSV は Shift-JIS → UTF-8 変換しつつ CSV を INSERT します。 // skipHeader=true のときだけ最初の１行をスキップします。 func loadCSV(db *sql.DB, filePath, table string, cols int, skipHeader bool) error { 	f, err := os.Open(filePath) 	if err != nil { 		return err 	} 	defer f.Close()  	rd := csv.NewReader(transform.NewReader(f, japanese.ShiftJIS.NewDecoder())) 	rd.LazyQuotes = true 	rd.FieldsPerRecord = -1  	if skipHeader { 		if _, err := rd.Read(); err != nil { 			return err 		} 	}  	tx, err := db.Begin() 	if err != nil { 		return err 	} 	defer func() { 		if err != nil { 			tx.Rollback() 		} 	}()  	ph := make([]string, cols) 	for i := range ph { 		ph[i] = "?" 	} 	stmt, err := tx.Prepare( 		"INSERT OR REPLACE INTO " + table + 			" VALUES(" + strings.Join(ph, ",") + ")", 	) 	if err != nil { 		return err 	} 	defer stmt.Close()  	for { 		rec, err := rd.Read() 		if err == io.EOF { 			break 		} 		if err != nil { 			return err 		} 		args := make([]interface{}, len(rec)) 		for i, v := range rec { 			args[i] = v 		} 		if _, err := stmt.Exec(args...); err != nil { 			return err 		} 	}  	return tx.Commit() }  func uploadDatHandler(w http.ResponseWriter, r *http.Request) { 	if r.Method != http.MethodPost { 		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed) 		return 	} 	if err := r.ParseMultipartForm(10 << 20); err != nil { 		http.Error(w, "Error parsing form: "+err.Error(), http.StatusBadRequest) 		return 	} 	files := r.MultipartForm.File["datFileInput[]"] 	if len(files) == 0 { 		http.Error(w, "No DAT file uploaded", http.StatusBadRequest) 		return 	}  	var all []dat.DATRecord 	total, created, dup := 0, 0, 0 	for _, fh := range files { 		file, err := fh.Open() 		if err != nil { 			log.Println("open DAT error:", err) 			continue 		} 		defer file.Close()  		recs, tc, mc, dc, err := dat.ParseDATFile(file) 		if err != nil { 			log.Println("parse DAT error:", err) 			continue 		} 		total += tc 		created += mc 		dup += dc 		all = append(all, recs...) 	}  	resp := map[string]interface{}{ 		"DATReadCount":    total, 		"MA0CreatedCount": created, 		"DuplicateCount":  dup, 		"DATRecords":      all, 	} 	w.Header().Set("Content-Type", "application/json") 	json.NewEncoder(w).Encode(resp) }  func uploadUsageHandler(w http.ResponseWriter, r *http.Request) { 	if r.Method != http.MethodPost { 		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed) 		return 	} 	if err := r.ParseMultipartForm(10 << 20); err != nil { 		http.Error(w, "Error parsing form: "+err.Error(), http.StatusBadRequest) 		return 	} 	files := r.MultipartForm.File["usageFileInput[]"] 	if len(files) == 0 { 		http.Error(w, "No USAGE file uploaded", http.StatusBadRequest) 		return 	}  	var all []usage.UsageRecord 	for _, fh := range files { 		file, err := fh.Open() 		if err != nil { 			log.Println("open USAGE error:", err) 			continue 		} 		defer file.Close()  		recs, err := usage.ParseUsageFile(file) 		if err != nil { 			log.Println("parse USAGE error:", err) 			continue 		} 		all = append(all, recs...) 	}  	w.Header().Set("Content-Type", "application/json") 	json.NewEncoder(w).Encode(map[string]interface{}{ 		"USAGERecords": all, 		"TotalRecords": len(all), 	}) }  func viewMA0Handler(w http.ResponseWriter, r *http.Request) { 	ma0.ViewMA0Handler(w, r) }  func autoLaunchBrowser(url string) { 	var cmd string 	var args []string 	switch runtime.GOOS { 	case "windows": 		cmd = "cmd" 		args = []string{"/c", "start", url} 	case "darwin": 		cmd = "open" 		args = []string{url} 	default: 		cmd = "xdg-open" 		args = []string{url} 	} 	if err := exec.Command(cmd, args...).Start(); err != nil { 		log.Printf("browser start failed: %v", err) 	} }  func main() { 	db, err := sql.Open("sqlite3", "yamato.db") 	if err != nil { 		log.Fatalf("DB open error: %v", err) 	} 	defer db.Close()  	ma0.DB = db  	schema, err := os.ReadFile("schema.sql") 	if err != nil { 		log.Fatalf("read schema.sql error: %v", err) 	} 	if _, err := db.Exec(string(schema)); err != nil { 		log.Fatalf("exec schema.sql error: %v", err) 	}  	jcshmsPath := `C:\Dev\YAMATO\SOU\JCSHMS.CSV` 	jancodePath := `C:\Dev\YAMATO\SOU\JANCODE.CSV` 	if err := loadCSV(db, jcshmsPath, "jcshms", 125, false); err != nil { 		log.Fatalf("load JCSHMS failed: %v", err) 	} 	if err := loadCSV(db, jancodePath, "jancode", 30, true); err != nil { 		log.Fatalf("load JANCODE failed: %v", err) 	}  	fs := http.FileServer(http.Dir("./static")) 	http.Handle("/", fs) 	http.HandleFunc("/uploadDat", uploadDatHandler) 	http.HandleFunc("/uploadUsage", uploadUsageHandler) 	http.HandleFunc("/viewMA0", viewMA0Handler)  	go autoLaunchBrowser("http://localhost:8080") 	log.Println("Server listening on :8080") 	log.Fatal(http.ListenAndServe(":8080", nil)) }

