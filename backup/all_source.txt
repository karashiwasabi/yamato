----- C:\Dev\YAMATO\dat\dat.go -----
package dat  import ( 	"bufio" 	"io" 	"log" 	"strings"  	"golang.org/x/text/encoding/japanese" 	"golang.org/x/text/transform"  	"YAMATO/ma0" // モジュール名は "wasabi" 固定 )  // DATRecord は、DATファイルから抽出する各フィールドを保持します。 // ※ 仕様書に基づき、エンコード変換は商品名など必要なものにのみ適用し、固定長フィールド（JANコードなど）はそのままのバイト列から抽出する必要がある。 // ここでは例として、JANコードの位置を仕様書準拠の raw[25:38]（13バイト）としている。 type DATRecord struct { 	DatOroshiCode         string // S行で取得した卸コード（例：raw[3:14]） 	DatDate               string // raw[4:12]（YYYYMMDD形式） 	DatDeliveryFlag       string // raw[3:4] 	DatReceiptNumber      string // raw[12:22] 	DatLineNumber         string // raw[22:24] 	DatJanCode            string // raw[25:38] ※仕様書準拠の位置 	DatProductName        string // raw[38:78] ※ここだけShift-JIS→UTF-8変換適用 	DatQuantity           string // raw[78:83] 	DatUnitPrice          string // raw[83:92] 	DatSubtotal           string // raw[92:101] 	DatPackagingDrugPrice string // raw[101:109] 	DatExpiryDate         string // raw[109:115] 	DatLotNumber          string // raw[115:121] }  // ParseDATFile は、io.Reader から DAT ファイルを Shift‑JIS のバイト列として読み込み、 // 固定長の各フィールドを仕様書に基づいて抽出し、 // さらに各行の DATRecord を返すとともに、総件数、新規MA0登録件数、重複件数の集計値も返します。 func ParseDATFile(r io.Reader) (records []DATRecord, totalCount, ma0CreatedCount, duplicateCount int, err error) { 	// ここでは全体に一律のエンコード変換はせず、各フィールドごとに適切な処理を行う前提。 	scanner := bufio.NewScanner(r) // r は raw のバイト列として読む（Shift-JIS変換は必要な箇所だけ後で行う） 	for scanner.Scan() { 		line := scanner.Text() 		// 行長チェックと識別子確認（仕様書：D行は "D20" など） 		if len(line) < 3 || !strings.HasPrefix(line, "D20") { 			continue 		} 		totalCount++  		// 固定長フィールド抽出用の関数 		getField := func(s string, start, end int) string { 			if len(s) >= end { 				return s[start:end] 			} 			if len(s) > start { 				return s[start:] 			} 			return "" 		}  		// ※ここでは仕様書に基づくバイト位置で抽出する。 		record := DATRecord{ 			DatOroshiCode:    getField(line, 3, 14), // 例：S行から取得した卸コード（共通として後続の処理で利用） 			DatDate:          getField(line, 4, 12), 			DatDeliveryFlag:  getField(line, 3, 4), 			DatReceiptNumber: getField(line, 12, 22), 			DatLineNumber:    getField(line, 22, 24), 			DatJanCode:       getField(line, 25, 38), // 仕様書に基づいた13バイトのJANコード 			// 商品名は Shift‑JIS→UTF‑8変換を適用する 			DatProductName: func(s string) string { 				// 商品名フィールドは raw[38:78] なのでここだけ変換 				utf8Str, _, errConv := transform.String(japanese.ShiftJIS.NewDecoder(), getField(s, 38, 78)) 				if errConv != nil { 					log.Printf("[DAT] 変換エラー: %v", errConv) 					return getField(s, 38, 78) // エラーならそのまま返す 				} 				return utf8Str 			}(line), 			DatQuantity:           getField(line, 78, 83), 			DatUnitPrice:          getField(line, 83, 92), 			DatSubtotal:           getField(line, 92, 101), 			DatPackagingDrugPrice: getField(line, 101, 109), 			DatExpiryDate:         getField(line, 109, 115), 			DatLotNumber:          getField(line, 115, 121), 		}  		records = append(records, record)  		// JANコードのチェック・MA0登録（ログ出力を実施） 		log.Printf("[DAT] DAT レコード JANチェック: %q", record.DatJanCode) 		_, created, err2 := ma0.CheckOrCreateMA0(record.DatJanCode) 		if err2 != nil { 			log.Printf("[DAT] エラー: JAN=%q: %v", record.DatJanCode, err2) 			continue 		} 		if created { 			ma0CreatedCount++ 			log.Printf("[DAT] → 新規MA0登録: %q", record.DatJanCode) 		} else { 			duplicateCount++ 		} 	} 	if err = scanner.Err(); err != nil { 		return 	} 	return }

----- C:\Dev\YAMATO\jancode\jancode.go -----
package jancode  import ( 	"encoding/csv" 	"io" 	"log" )  // JAFields は、JANCODE CSVから取り出す JA領域の各フィールドを保持する構造体です。 // 例として、JA000、JA001、JA029 を定義していますが、必要に応じて中間のフィールドも追加してください。 type JAFields struct { 	JA000 string 	JA001 string 	JA002 string 	JA003 string 	JA004 string 	JA005 string 	JA006 string 	JA007 string 	JA008 string 	JA009 string 	JA010 string 	JA011 string 	JA012 string 	JA013 string 	JA014 string 	JA015 string 	JA016 string 	JA017 string 	JA018 string 	JA019 string 	JA020 string 	JA021 string 	JA022 string 	JA023 string 	JA024 string 	JA025 string 	JA026 string 	JA027 string 	JA028 string 	JA029 string }  // JANCODERecord は、JANCODE CSVの1行分のデータを表します。 // キーは、フィールド1の値（JANコード）として使用し、JA領域の情報を保持します。 type JANCODERecord struct { 	JANCode string   // CSVのインデックス1 (JANコード) 	JA      JAFields // JA領域の情報 }  // ParseJANCODE は、入力の io.Reader から CSV データを読み込み、 // ヘッダー行をスキップした上で各行を JANCODERecord のスライスに変換して返します。 // CSVは各行が少なくとも30フィールド（インデックス0～29）を持つことを前提としています。 func ParseJANCODE(r io.Reader) ([]JANCODERecord, error) { 	reader := csv.NewReader(r) 	rows, err := reader.ReadAll() 	if err != nil { 		return nil, err 	}  	var records []JANCODERecord 	for i, row := range rows { 		// 1行目はヘッダーのためスキップ 		if i == 0 { 			continue 		}  		if len(row) < 30 { 			log.Printf("Row %d: insufficient fields (%d)", i+1, len(row)) 			continue 		}  		ja := JAFields{ 			JA000: row[0], 			JA001: row[1], 			JA002: row[2], 			JA003: row[3], 			JA004: row[4], 			JA005: row[5], 			JA006: row[6], 			JA007: row[7], 			JA008: row[8], 			JA009: row[9], 			JA010: row[10], 			JA011: row[11], 			JA012: row[12], 			JA013: row[13], 			JA014: row[14], 			JA015: row[15], 			JA016: row[16], 			JA017: row[17], 			JA018: row[18], 			JA019: row[19], 			JA020: row[20], 			JA021: row[21], 			JA022: row[22], 			JA023: row[23], 			JA024: row[24], 			JA025: row[25], 			JA026: row[26], 			JA027: row[27], 			JA028: row[28], 			JA029: row[29], 		}  		record := JANCODERecord{ 			JANCode: row[1], // キーとしてフィールド1の値を使用 			JA:      ja, 		}  		records = append(records, record) 	} 	return records, nil }

----- C:\Dev\YAMATO\jchms\jchms.go -----
package jchms  import ( 	"encoding/csv" 	"io" 	"log" )  // JCFields は、JCHMAS CSVから取り出す JC 領域の各フィールドを保持する構造体です。 // ここでは例として JC000, JC001, JC124 を定義していますが、必要に応じて他のフィールドも追加してください。 type JCFields struct { 	JC000 string 	JC001 string 	JC002 string 	JC003 string 	JC004 string 	JC005 string 	JC006 string 	JC007 string 	JC008 string 	JC009 string 	JC010 string 	JC011 string 	JC012 string 	JC013 string 	JC014 string 	JC015 string 	JC016 string 	JC017 string 	JC018 string 	JC019 string 	JC020 string 	JC021 string 	JC022 string 	JC023 string 	JC024 string 	JC025 string 	JC026 string 	JC027 string 	JC028 string 	JC029 string 	JC030 string 	JC031 string 	JC032 string 	JC033 string 	JC034 string 	JC035 string 	JC036 string 	JC037 string 	JC038 string 	JC039 string 	JC040 string 	JC041 string 	JC042 string 	JC043 string 	JC044 string 	JC045 string 	JC046 string 	JC047 string 	JC048 string 	JC049 string 	JC050 string 	JC051 string 	JC052 string 	JC053 string 	JC054 string 	JC055 string 	JC056 string 	JC057 string 	JC058 string 	JC059 string 	JC060 string 	JC061 string 	JC062 string 	JC063 string 	JC064 string 	JC065 string 	JC066 string 	JC067 string 	JC068 string 	JC069 string 	JC070 string 	JC071 string 	JC072 string 	JC073 string 	JC074 string 	JC075 string 	JC076 string 	JC077 string 	JC078 string 	JC079 string 	JC080 string 	JC081 string 	JC082 string 	JC083 string 	JC084 string 	JC085 string 	JC086 string 	JC087 string 	JC088 string 	JC089 string 	JC090 string 	JC091 string 	JC092 string 	JC093 string 	JC094 string 	JC095 string 	JC096 string 	JC097 string 	JC098 string 	JC099 string 	JC100 string 	JC101 string 	JC102 string 	JC103 string 	JC104 string 	JC105 string 	JC106 string 	JC107 string 	JC108 string 	JC109 string 	JC110 string 	JC111 string 	JC112 string 	JC113 string 	JC114 string 	JC115 string 	JC116 string 	JC117 string 	JC118 string 	JC119 string 	JC120 string 	JC121 string 	JC122 string 	JC123 string 	JC124 string }  // JCHMASRecord は、JCHMAS（旧JCHMS）CSVの1行分を表します。 // キーはフィールド0（JANコード）とし、JC領域の情報を構造体として保持します。 type JCHMASRecord struct { 	JANCode string   // CSV のインデックス0 (JANコード) 	JC      JCFields // JC 領域の情報 }  // ParseJCHMAS は、入力の io.Reader から CSV データを読み込み、 // 各行を JCHMASRecord のスライスに変換して返します。 // CSV はヘッダーなしで、各行は少なくとも 125 フィールド（0〜124）を持つことが前提です。 func ParseJCHMAS(r io.Reader) ([]JCHMASRecord, error) { 	reader := csv.NewReader(r) 	rows, err := reader.ReadAll() 	if err != nil { 		return nil, err 	}  	var records []JCHMASRecord 	for i, row := range rows { 		// 行のフィールド数が125未満の場合は、警告を出してその行をスキップ 		if len(row) < 125 { 			log.Printf("Row %d: insufficient fields (%d)", i+1, len(row)) 			continue 		}  		// JC領域のデータを構造体に格納 		jc := JCFields{ 			JC000: row[0], 			JC001: row[1], 			JC002: row[2], 			JC003: row[3], 			JC004: row[4], 			JC005: row[5], 			JC006: row[6], 			JC007: row[7], 			JC008: row[8], 			JC009: row[9], 			JC010: row[10], 			JC011: row[11], 			JC012: row[12], 			JC013: row[13], 			JC014: row[14], 			JC015: row[15], 			JC016: row[16], 			JC017: row[17], 			JC018: row[18], 			JC019: row[19], 			JC020: row[20], 			JC021: row[21], 			JC022: row[22], 			JC023: row[23], 			JC024: row[24], 			JC025: row[25], 			JC026: row[26], 			JC027: row[27], 			JC028: row[28], 			JC029: row[29], 			JC030: row[30], 			JC031: row[31], 			JC032: row[32], 			JC033: row[33], 			JC034: row[34], 			JC035: row[35], 			JC036: row[36], 			JC037: row[37], 			JC038: row[38], 			JC039: row[39], 			JC040: row[40], 			JC041: row[41], 			JC042: row[42], 			JC043: row[43], 			JC044: row[44], 			JC045: row[45], 			JC046: row[46], 			JC047: row[47], 			JC048: row[48], 			JC049: row[49], 			JC050: row[50], 			JC051: row[51], 			JC052: row[52], 			JC053: row[53], 			JC054: row[54], 			JC055: row[55], 			JC056: row[56], 			JC057: row[57], 			JC058: row[58], 			JC059: row[59], 			JC060: row[60], 			JC061: row[61], 			JC062: row[62], 			JC063: row[63], 			JC064: row[64], 			JC065: row[65], 			JC066: row[66], 			JC067: row[67], 			JC068: row[68], 			JC069: row[69], 			JC070: row[70], 			JC071: row[71], 			JC072: row[72], 			JC073: row[73], 			JC074: row[74], 			JC075: row[75], 			JC076: row[76], 			JC077: row[77], 			JC078: row[78], 			JC079: row[79], 			JC080: row[80], 			JC081: row[81], 			JC082: row[82], 			JC083: row[83], 			JC084: row[84], 			JC085: row[85], 			JC086: row[86], 			JC087: row[87], 			JC088: row[88], 			JC089: row[89], 			JC090: row[90], 			JC091: row[91], 			JC092: row[92], 			JC093: row[93], 			JC094: row[94], 			JC095: row[95], 			JC096: row[96], 			JC097: row[97], 			JC098: row[98], 			JC099: row[99], 			JC100: row[100], 			JC101: row[101], 			JC102: row[102], 			JC103: row[103], 			JC104: row[104], 			JC105: row[105], 			JC106: row[106], 			JC107: row[107], 			JC108: row[108], 			JC109: row[109], 			JC110: row[110], 			JC111: row[111], 			JC112: row[112], 			JC113: row[113], 			JC114: row[114], 			JC115: row[115], 			JC116: row[116], 			JC117: row[117], 			JC118: row[118], 			JC119: row[119], 			JC120: row[120], 			JC121: row[121], 			JC122: row[122], 			JC123: row[123], 			JC124: row[124], 		}  		// レコードを生成（キーは row[0] の JANコード） 		record := JCHMASRecord{ 			JANCode: row[0], 			JC:      jc, 		} 		records = append(records, record) 	} 	return records, nil }

----- C:\Dev\YAMATO\js\dat.js -----
document.addEventListener('DOMContentLoaded', () => {   const uploadBtn = document.getElementById('uploadBtn');   const fileInput = document.getElementById('fileInput');   const indicator = document.getElementById('indicator');   const output = document.getElementById('output');    if (!uploadBtn || !fileInput || !indicator || !output) {     console.error("必要な DOM 要素が見つかりません。HTML を確認してください。");     return;   }    // アップロードボタンをクリックでファイル選択ダイアログを表示   uploadBtn.addEventListener('click', () => {     fileInput.click();   });    fileInput.addEventListener('change', async () => {     const files = fileInput.files;     if (!files || files.length === 0) {       console.warn("ファイルが選択されていません。");       return;     }      // Indicator に選択されたファイル数を表示     indicator.textContent = `${files.length} 個のファイルが選択されました。`;      let results = [];     // 各ファイルを1個ずつアップロード     for (let i = 0; i < files.length; i++) {       const formData = new FormData();       formData.append('file', files[i]);        try {         const res = await fetch('/upload', {           method: 'POST',           body: formData         });         if (!res.ok) throw new Error(`HTTPエラー: ${res.status}`);         // レスポンスはプレーンテキストとして受け取る         const text = await res.text();         results.push(`[${files[i].name}]:\n${text}`);       } catch (err) {         results.push(`[${files[i].name}]: アップロード失敗 (${err.message})`);       }     }     output.textContent = results.join("\n\n");     indicator.textContent += " アップロード処理が完了しました。";     fileInput.value = '';   }); });

----- C:\Dev\YAMATO\ma0\mao.go -----
package ma0  import ( 	"encoding/json" 	"net/http" 	"sync" )  // MA0Record は MA0 の各レコード情報を保持する構造体です。 type MA0Record struct { 	JANCode          string `json:"janCode"` 	PackagingUnit    string `json:"packagingUnit"` 	ConversionFactor string `json:"conversionFactor"` }  var ( 	// ma0Data は in‑memory のマスター情報を保持します。 	ma0Data = make(map[string]MA0Record) 	// mutex により同時アクセスの排他制御を行います。 	mutex sync.Mutex )  // CheckOrCreateMA0 は、指定された JAN コードについて、 // 既に登録済みかをチェックし、存在すればそのレコードと false を返し、 // 存在しなければダミー値（PackagingUnit: "錠", ConversionFactor: "100"）を用いて // 新規に登録し、登録したレコードと true を返します。エラーは基本的に発生しません。 func CheckOrCreateMA0(jan string) (MA0Record, bool, error) { 	mutex.Lock() 	defer mutex.Unlock()  	if rec, exists := ma0Data[jan]; exists { 		return rec, false, nil 	}  	newRec := MA0Record{ 		JANCode:          jan, 		PackagingUnit:    "錠",   // 仮の値。実際はマスターCSVから取得するなどの処理を追加可能 		ConversionFactor: "100", // 仮の値 	} 	ma0Data[jan] = newRec 	return newRec, true, nil }  // ViewMA0Handler は、現在の MA0 の中身（登録された MA0Record の一覧）を JSON 形式で返却します。 func ViewMA0Handler(w http.ResponseWriter, r *http.Request) { 	mutex.Lock() 	defer mutex.Unlock()  	// ma0Data をスライスに変換して返す。 	var records []MA0Record 	for _, rec := range ma0Data { 		records = append(records, rec) 	}  	w.Header().Set("Content-Type", "application/json") 	json.NewEncoder(w).Encode(map[string]interface{}{ 		"MA0Records": records, 	}) }

----- C:\Dev\YAMATO\static\css\styles.css -----
body {   font-family: Arial, sans-serif;   margin: 1em; } header button {   margin-right: .5em;   padding: .4em 1em; } #indicator {   margin: 1em 0;   font-weight: bold; } #outputTable {   width: 100%;   border-collapse: collapse; } #outputTable th, #outputTable td {   border: 1px solid #ccc;   padding: .3em .6em;   font-size: .85em; } #outputTable th {   background: #f0f0f0;   text-align: left; }

----- C:\Dev\YAMATO\static\js\dat.js -----
document.addEventListener('DOMContentLoaded', () => {   const btn       = document.getElementById('datBtn');   const input     = document.getElementById('datInput');   const indicator = document.getElementById('indicator');   const table     = document.getElementById('outputTable');   const thead     = table.querySelector('thead');   const tbody     = table.querySelector('tbody');    // DATファイルアップロードボタンをクリックすると、隠しファイル入力がトリガーされる   btn.addEventListener('click', () => input.click());    input.addEventListener('change', async () => {     if (!input.files.length) return;     indicator.textContent = 'DATアップロード中…';          // テーブルの内容はクリアする（必要に応じてテーブルへの出力処理を追加可能）     thead.innerHTML = '';     tbody.innerHTML = '';      // 選択された各ファイルについて処理する     for (let file of input.files) {       const form = new FormData();       form.append('datFileInput[]', file);        try {         const res = await fetch('/uploadDat', { method: 'POST', body: form });         // サーバーから返却されるJSONはオブジェクト形式なので、そのままresultとして扱う         const result = await res.json();         indicator.textContent = `${file.name}: DAT読み込み: ${result.DATReadCount} 件 | MA0作成: ${result.MA0CreatedCount} 件 | 重複: ${result.DuplicateCount} 件`;                  // ※ 必要に応じて、resultを用いたテーブル表示処理を追加してください。       } catch (err) {         indicator.textContent = "アップロード中にエラーが発生しました: " + err.message;         console.error(err);       }     }     indicator.textContent += " 完了";     // 処理後、ファイル入力の値をリセット     input.value = '';   }); });

----- C:\Dev\YAMATO\static\js\ma0.js -----
document.addEventListener('DOMContentLoaded', () => {   const ma0Btn = document.getElementById('ma0Btn');   const ma0Container = document.getElementById('ma0Container');   const indicator = document.getElementById('indicator');    ma0Btn.addEventListener('click', async () => {     indicator.textContent = 'MA0表示中…';     try {       const res = await fetch('/viewMA0');       if (!res.ok) throw new Error(`HTTPステータス: ${res.status}`);        // サーバから返却される JSON データは、"MA0Records" キーに MA0Record の配列が入っているものとする       const data = await res.json();        if (data.MA0Records && data.MA0Records.length > 0) {         ma0Container.innerHTML =           `<h2>MA0レコード（${data.MA0Records.length} 件）</h2>` +           `<ul>` +           data.MA0Records             .map(rec => `<li>${rec.janCode} (包装単位: ${rec.packagingUnit}, 換算係数: ${rec.conversionFactor})</li>`)             .join('') +           `</ul>`;       } else {         ma0Container.innerHTML = `<h2>MA0は空です。</h2>`;       }       indicator.textContent = '';     } catch (err) {       indicator.textContent = "MA0の表示中にエラー: " + err.message;       console.error(err);     }   }); });

----- C:\Dev\YAMATO\static\js\usage.js -----
document.addEventListener('DOMContentLoaded', () => {   const usageBtn   = document.getElementById('usageBtn');   const usageInput = document.getElementById('usageInput');   const indicator  = document.getElementById('indicator');   const table      = document.getElementById('outputTable');   const thead      = table.querySelector('thead');   const tbody      = table.querySelector('tbody');    // USAGE用アップロードボタンがクリックされたときに隠しファイル入力を開く   usageBtn.addEventListener('click', () => usageInput.click());    usageInput.addEventListener('change', async () => {     if (!usageInput.files || usageInput.files.length === 0) return;          indicator.textContent = 'USAGEアップロード中…';     thead.innerHTML = '';     tbody.innerHTML = '';      for (let file of usageInput.files) {       const formData = new FormData();       formData.append('usageFileInput[]', file);        try {         const res = await fetch('/uploadUsage', { method: 'POST', body: formData });         if (!res.ok) {           // HTTPエラーの場合、エラーメッセージ用のHTMLが返却されるので例外を投げる           throw new Error(`アップロードに失敗しました。HTTPステータス: ${res.status}`);         }         // サーバからはJSONが返却されるので、それをパースする         const result = await res.json();         // 例として、resultに TotalRecords, OrganizedCount, MA0NewRecordCount が含まれているとする         indicator.textContent = `${file.name}: USAGE読み込み: ${result.TotalRecords} 件 | Organized: ${result.OrganizedCount} 件 | MA0新規追記: ${result.MA0NewRecordCount} 件`;                  // ※ ここで、resultの内容をテーブルに出力する処理を追加することも可能です。       } catch (error) {         indicator.textContent = "アップロード中にエラーが発生しました: " + error.message;         console.error("アップロードエラー:", error);       }     }     indicator.textContent += " 完了";     usageInput.value = '';   }); });  

----- C:\Dev\YAMATO\static\index.html -----
<!DOCTYPE html> <html lang="ja"> <head>   <meta charset="UTF-8">   <title>YAMATO Upload</title>   <!-- 必要に応じてスタイルシートを調整 -->   <link rel="stylesheet" href="css/styles.css"> </head> <body>   <header>     <!-- DATファイルアップロードボタン -->     <button id="datBtn">DATファイルアップロード</button>     <!-- USAGEファイルアップロードボタン -->     <button id="usageBtn">USAGEファイルアップロード</button>     <!-- MA0確認ボタン -->     <button id="ma0Btn">MA0確認</button>   </header>      <!-- アップロード処理の進捗や結果を表示するエリア -->   <section id="indicator"></section>      <!-- MA0の中身を表示するエリア -->   <section id="ma0Container"></section>      <!-- 解析結果（必要に応じてテーブル表示） -->   <table id="outputTable">     <thead></thead>     <tbody></tbody>   </table>      <!-- 隠しのファイル入力（DAT/USAGE用） -->   <input type="file" id="datInput" accept=".dat" multiple hidden>   <input type="file" id="usageInput" accept=".csv" multiple hidden>      <!-- JavaScriptファイルの読み込み -->   <script src="js/dat.js"></script>   <script src="js/usage.js"></script>   <script src="js/ma0.js"></script> </body> </html>

----- C:\Dev\YAMATO\usage\usage.go -----
package usage  import ( 	"bufio" 	"io" 	"log" 	"strings"  	"golang.org/x/text/encoding/japanese" 	"golang.org/x/text/transform"  	"YAMATO/ma0" )  // ParseUsageFile は USAGE CSV ファイルを解析し、JANコードを MA0 に登録する。 func ParseUsageFile(r io.Reader) (totalRecords, organizedCount, ma0NewCount int, err error) { 	scanner := bufio.NewScanner(transform.NewReader(r, japanese.ShiftJIS.NewDecoder())) 	headerSkipped := false  	for scanner.Scan() { 		line := scanner.Text() 		if !headerSkipped { 			if strings.Contains(line, "UsageDate") { 				headerSkipped = true 				continue 			} 			headerSkipped = true 		} 		totalRecords++  		fields := strings.Split(line, ",") 		if len(fields) < 3 { 			continue 		}  		jan := strings.TrimSpace(fields[2]) 		log.Printf("[USAGE] JANチェック: %q", jan)  		_, created, err2 := ma0.CheckOrCreateMA0(jan) 		if err2 != nil { 			log.Printf("[USAGE] エラー: JAN=%q: %v", jan, err2) 			continue 		} 		if created { 			ma0NewCount++ 			log.Printf("[USAGE] → 新規MA0登録: %q", jan) 		} 		organizedCount++ 	} 	if err = scanner.Err(); err != nil { 		return 	} 	return }

----- C:\Dev\YAMATO\main.go -----
package main  import ( 	"encoding/json" 	"log" 	"net/http" 	"os/exec" 	"runtime"  	"YAMATO/dat" 	"YAMATO/ma0" 	"YAMATO/usage" )  func uploadDatHandler(w http.ResponseWriter, r *http.Request) { 	if r.Method != http.MethodPost { 		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed) 		return 	} 	err := r.ParseMultipartForm(10 << 20) 	if err != nil { 		http.Error(w, "Error parsing form: "+err.Error(), http.StatusBadRequest) 		return 	} 	files := r.MultipartForm.File["datFileInput[]"] 	if len(files) == 0 { 		http.Error(w, "No DAT file uploaded", http.StatusBadRequest) 		return 	}  	var allRecords []dat.DATRecord 	totalCount, ma0CreatedCount, duplicateCount := 0, 0, 0 	for _, fileHeader := range files { 		file, err := fileHeader.Open() 		if err != nil { 			log.Println("Error opening DAT file:", err) 			continue 		} 		defer file.Close()  		records, tc, mc, dc, err := dat.ParseDATFile(file) 		if err != nil { 			log.Println("Error parsing DAT file:", err) 			continue 		} 		totalCount += tc 		ma0CreatedCount += mc 		duplicateCount += dc 		allRecords = append(allRecords, records...) 	}  	resp := map[string]interface{}{ 		"DATReadCount":    totalCount, 		"MA0CreatedCount": ma0CreatedCount, 		"DuplicateCount":  duplicateCount, 		"DATRecords":      allRecords, // ここにDATの内容をすべて含む 	} 	w.Header().Set("Content-Type", "application/json") 	json.NewEncoder(w).Encode(resp) }  func uploadUsageHandler(w http.ResponseWriter, r *http.Request) { 	// USAGE処理は従来の実装と同様 	if r.Method != http.MethodPost { 		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed) 		return 	} 	err := r.ParseMultipartForm(10 << 20) 	if err != nil { 		http.Error(w, "Error parsing form: "+err.Error(), http.StatusBadRequest) 		return 	} 	files := r.MultipartForm.File["usageFileInput[]"] 	if len(files) == 0 { 		http.Error(w, "No USAGE file uploaded", http.StatusBadRequest) 		return 	}  	totalRecords, organizedCount, ma0NewCount := 0, 0, 0 	for _, fileHeader := range files { 		file, err := fileHeader.Open() 		if err != nil { 			log.Println("Error opening USAGE file:", err) 			continue 		} 		defer file.Close() 		tr, oc, nc, err := usage.ParseUsageFile(file) 		if err != nil { 			log.Println("Error parsing USAGE file:", err) 			continue 		} 		totalRecords += tr 		organizedCount += oc 		ma0NewCount += nc 	} 	w.Header().Set("Content-Type", "application/json") 	resp := map[string]int{ 		"TotalRecords":      totalRecords, 		"OrganizedCount":    organizedCount, 		"MA0NewRecordCount": ma0NewCount, 	} 	json.NewEncoder(w).Encode(resp) }  func viewMA0Handler(w http.ResponseWriter, r *http.Request) { 	ma0.ViewMA0Handler(w, r) }  func autoLaunchBrowser(url string) { 	var cmd string 	var args []string 	switch runtime.GOOS { 	case "windows": 		cmd = "cmd" 		args = []string{"/c", "start", url} 	case "darwin": 		cmd = "open" 		args = []string{url} 	default: 		cmd = "xdg-open" 		args = []string{url} 	} 	if err := exec.Command(cmd, args...).Start(); err != nil { 		log.Printf("Browser auto-launch failed: %v", err) 	} }  func main() { 	fs := http.FileServer(http.Dir("./static")) 	http.Handle("/", fs) 	http.HandleFunc("/uploadDat", uploadDatHandler) 	http.HandleFunc("/uploadUsage", uploadUsageHandler) 	http.HandleFunc("/viewMA0", viewMA0Handler) 	go autoLaunchBrowser("http://localhost:8080") 	log.Println("Server starting on port :8080") 	if err := http.ListenAndServe(":8080", nil); err != nil { 		log.Fatal("ListenAndServe:", err) 	} }

